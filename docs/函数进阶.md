# Q 语言教程 - 函数进阶

## 目录

1. [函数基础回顾](#函数基础回顾)
2. [参数进阶](#参数进阶)
3. [返回值](#返回值)
4. [闭包和捕获](#闭包和捕获)
5. [高阶函数](#高阶函数)
6. [递归函数](#递归函数)
7. [内置函数](#内置函数)

---

## 函数基础回顾

### 函数定义

Q 语言中的函数都是闭包，通过 `func` 关键字定义并赋值给变量：

```q
// 无参数无返回值
var sayHello = func() {
    println("Hello!")
}

// 有参数和返回值
var add = func(a: int, b: int) int {
    return a + b
}

// 调用
sayHello()
var result = add(10, 20)
```

### 包级函数

在包级别（函数外）定义的函数：

```q
package myapp

// 包级函数（全局函数）
func greet(name: string) {
    println("Hello, " + name)
}

func main() {
    greet("World")
}
```

---

## 参数进阶

### 默认参数

函数参数可以有默认值：

```q
var greet = func(name: string, greeting: string = "Hello") string {
    return greeting + ", " + name + "!"
}

println(greet("Alice"))          // "Hello, Alice!"
println(greet("Bob", "Hi"))      // "Hi, Bob!"
```

### 默认参数规则

```q
// 正确：默认参数在后面
var func1 = func(a: int, b: int = 10, c: int = 20) int {
    return a + b + c
}

// 错误：默认参数后面不能有必需参数
// var func2 = func(a: int = 10, b: int) int {
//     return a + b
// }
```

### 可变参数

使用 `...` 声明可变参数（必须是最后一个参数）：

```q
var sum = func(numbers: int...) int {
    var total = 0
    for n in numbers {
        total += n
    }
    return total
}

println(sum(1, 2, 3))          // 6
println(sum(1, 2, 3, 4, 5))    // 15
println(sum())                  // 0（空参数）
```

### 混合使用参数类型

```q
var calculate = func(
    operation: string,      // 必需参数
    x: int,                 // 必需参数
    y: int = 0,            // 默认参数
    extra: int...          // 可变参数
) int {
    var result = 0
    
    if operation == "add" {
        result = x + y
    } else if operation == "multiply" {
        result = x * y
    }
    
    for val in extra {
        result += val
    }
    
    return result
}

println(calculate("add", 10, 20))           // 30
println(calculate("add", 10, 20, 5, 10))    // 45
```

### 展开数组作为可变参数

```q
var sum = func(numbers: int...) int {
    var total = 0
    for n in numbers {
        total += n
    }
    return total
}

var arr = [1, 2, 3, 4, 5]
// 注意：当前版本可能不支持数组展开
// var result = sum(arr...)
```

---

## 返回值

### 单返回值

```q
var square = func(x: int) int {
    return x * x
}

var getValue = func() string {
    return "Hello"
}
```

### 多返回值

Q 语言支持函数返回多个值：

```q
var divmod = func(a: int, b: int) (int, int) {
    return a / b, a % b
}

// 必须接收所有返回值
var quotient, remainder = divmod(17, 5)
println(quotient)   // 3
println(remainder)  // 2
```

### 提前返回

```q
var checkAge = func(age: int) string {
    if age < 0 {
        return "Invalid age"
    }
    
    if age < 18 {
        return "Minor"
    }
    
    if age < 65 {
        return "Adult"
    }
    
    return "Senior"
}
```

### void 返回类型

```q
var printMessage = func(msg: string) void {
    println(msg)
    // 无需 return 语句
}

// 或者省略 void（默认）
var printMessage2 = func(msg: string) {
    println(msg)
}
```

### 提前返回（void 函数）

```q
var processValue = func(value: int) {
    if value < 0 {
        println("Negative value, skipping")
        return  // 直接返回，不带值
    }
    
    println("Processing: " + value as string)
}
```

---

## 闭包和捕获

### 基本闭包捕获

闭包可以捕获外部变量：

```q
var makeCounter = func() func() int {
    var count = 0  // 被闭包捕获
    
    return func() int {
        count += 1
        return count
    }
}

var counter1 = makeCounter()
println(counter1())  // 1
println(counter1())  // 2
println(counter1())  // 3

var counter2 = makeCounter()
println(counter2())  // 1（独立的计数器）
```

### 多个闭包共享状态

```q
var makeCounter2 = func() (func() int, func()) {
    var count = 0
    
    var increment = func() int {
        count += 1
        return count
    }
    
    var reset = func() {
        count = 0
    }
    
    return increment, reset
}

var inc, rst = makeCounter2()
println(inc())  // 1
println(inc())  // 2
rst()
println(inc())  // 1
```

### 闭包捕获循环变量

```q
var makeFunctions = func() func()[] {
    var funcs: func()[] = []
    
    for var i = 0; i < 3; i++ {
        // 注意：捕获的是变量 i，不是值
        var f = func() {
            println(i)
        }
        // funcs.append(f)  // 可能需要数组方法支持
    }
    
    return funcs
}
```

---

## 高阶函数

### 函数作为参数

```q
// 接受函数作为参数
var apply = func(a: int, b: int, op: func(int, int) int) int {
    return op(a, b)
}

var add = func(x: int, y: int) int {
    return x + y
}

var multiply = func(x: int, y: int) int {
    return x * y
}

println(apply(10, 20, add))       // 30
println(apply(10, 20, multiply))  // 200
```

### 函数作为返回值

```q
var makeMultiplier = func(factor: int) func(int) int {
    return func(x: int) int {
        return x * factor
    }
}

var double = makeMultiplier(2)
var triple = makeMultiplier(3)

println(double(10))  // 20
println(triple(10))  // 30
```

### 函数组合

```q
var compose = func(
    f: func(int) int,
    g: func(int) int
) func(int) int {
    return func(x: int) int {
        return f(g(x))
    }
}

var addOne = func(x: int) int {
    return x + 1
}

var double = func(x: int) int {
    return x * 2
}

var addOneThenDouble = compose(double, addOne)
println(addOneThenDouble(5))  // 12 (5 + 1 = 6, 6 * 2 = 12)
```

### 常见高阶函数模式

#### Map（映射）

```q
var map = func(arr: int[], f: func(int) int) int[] {
    var result: int[] = []
    for item in arr {
        // result.append(f(item))  // 需要数组方法支持
    }
    return result
}

var numbers = [1, 2, 3, 4, 5]
var double = func(x: int) int { return x * 2 }
// var doubled = map(numbers, double)
```

#### Filter（过滤）

```q
var filter = func(arr: int[], predicate: func(int) bool) int[] {
    var result: int[] = []
    for item in arr {
        if predicate(item) {
            // result.append(item)
        }
    }
    return result
}

var isEven = func(x: int) bool {
    return x % 2 == 0
}
// var evens = filter([1, 2, 3, 4, 5], isEven)
```

#### Reduce（归约）

```q
var reduce = func(
    arr: int[],
    initial: int,
    reducer: func(int, int) int
) int {
    var result = initial
    for item in arr {
        result = reducer(result, item)
    }
    return result
}

var add = func(a: int, b: int) int { return a + b }
var sum = reduce([1, 2, 3, 4, 5], 0, add)
println(sum)  // 15
```

---

## 递归函数

### 简单递归

```q
var factorial = func(n: int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

println(factorial(5))  // 120
println(factorial(10)) // 3628800
```

### 尾递归

```q
// 尾递归版本的阶乘
var factorialTail = func(n: int, acc: int) int {
    if n <= 1 {
        return acc
    }
    return factorialTail(n - 1, acc * n)
}

var factorial = func(n: int) int {
    return factorialTail(n, 1)
}

println(factorial(5))  // 120
```

### 递归遍历

```q
// 斐波那契数列
var fib = func(n: int) int {
    if n <= 1 {
        return n
    }
    return fib(n - 1) + fib(n - 2)
}

for var i = 0; i < 10; i++ {
    println(fib(i))
}
// 输出：0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

### 相互递归

```q
// 前向声明（通过变量）
var isOdd: func(int) bool
var isEven: func(int) bool

isOdd = func(n: int) bool {
    if n == 0 {
        return false
    }
    return isEven(n - 1)
}

isEven = func(n: int) bool {
    if n == 0 {
        return true
    }
    return isOdd(n - 1)
}

println(isEven(4))  // true
println(isOdd(7))   // true
```

---

## 内置函数

Q 语言提供了一些内置函数（不属于任何类）：

### print

输出到控制台（不换行）：

```q
print("Hello")
print(" ")
print("World")
// 输出：Hello World
```

### println

输出到控制台（换行）：

```q
println("Hello")
println("World")
// 输出：
// Hello
// World
```

### typeof

获取类型信息（用于反射）：

```q
var value = 42
var typeInfo = typeof(value)
println(typeInfo)

class User {}
var userType = typeof(User)
```

### sizeof

获取类型大小（字节）：

```q
var size1 = sizeof(int)     // 平台相关
var size2 = sizeof(i32)     // 4
var size3 = sizeof(f64)     // 8

println(size1)
println(size2)
```

### panic

触发运行时错误，终止程序：

```q
var divide = func(a: int, b: int) int {
    if b == 0 {
        panic("Division by zero")
    }
    return a / b
}

// divide(10, 0)  // 会触发 panic
```

---

## 完整示例

### 示例 1：函数工具库

```q
class FuncUtils {
    // 函数组合
    static func compose<T>(
        f: func(T) T,
        g: func(T) T
    ) func(T) T {
        return func(x: T) T {
            return f(g(x))
        }
    }
    
    // 柯里化（简化版）
    static func curry(
        f: func(int, int) int,
        a: int
    ) func(int) int {
        return func(b: int) int {
            return f(a, b)
        }
    }
}

// 使用
var add = func(a: int, b: int) int {
    return a + b
}

var addFive = FuncUtils::curry(add, 5)
println(addFive(10))  // 15
println(addFive(20))  // 25
```

### 示例 2：回调系统

```q
class EventEmitter {
    callbacks: func()[]
    
    func init() {
        this.callbacks = []
    }
    
    func on(callback: func()) {
        // this.callbacks.append(callback)
    }
    
    func emit() {
        for callback in this.callbacks {
            callback()
        }
    }
}

var emitter = new EventEmitter()

emitter.on(func() {
    println("Event 1")
})

emitter.on(func() {
    println("Event 2")
})

emitter.emit()
// 输出：
// Event 1
// Event 2
```

### 示例 3：策略模式

```q
// 排序策略
type CompareFunc = func(int, int) bool

var sort = func(arr: int[], compare: CompareFunc) int[] {
    // 简化的冒泡排序
    var result = arr
    var n = result[0]  // 简化示例
    
    // 实际排序逻辑...
    return result
}

// 升序比较
var ascending = func(a: int, b: int) bool {
    return a < b
}

// 降序比较
var descending = func(a: int, b: int) bool {
    return a > b
}

var numbers = [5, 2, 8, 1, 9]
// var sortedAsc = sort(numbers, ascending)
// var sortedDesc = sort(numbers, descending)
```

### 示例 4：记忆化

```q
var memoize = func(f: func(int) int) func(int) int {
    var cache: map[int]int = {}
    
    return func(n: int) int {
        // 简化版（需要 map 方法支持）
        if cache[n] != 0 {
            return cache[n]
        }
        
        var result = f(n)
        cache[n] = result
        return result
    }
}

// 未优化的斐波那契
var slowFib = func(n: int) int {
    if n <= 1 {
        return n
    }
    return slowFib(n - 1) + slowFib(n - 2)
}

// 记忆化版本
var fastFib = memoize(slowFib)
```

---

## 最佳实践

### 1. 函数应该做一件事

```q
// 好：单一职责
var calculateTotal = func(items: int[]) int {
    var sum = 0
    for item in items {
        sum += item
    }
    return sum
}

// 不好：做太多事
var processAndPrint = func(items: int[]) {
    var sum = 0
    for item in items {
        sum += item
    }
    println(sum)
    // 混合了计算和输出
}
```

### 2. 使用有意义的参数名

```q
// 好
var calculateDistance = func(x1: int, y1: int, x2: int, y2: int) f64 {
    // ...
}

// 不好
var calc = func(a: int, b: int, c: int, d: int) f64 {
    // ...
}
```

### 3. 限制参数数量

```q
// 好：参数少
var createUser = func(name: string, age: int) User {
    // ...
}

// 考虑使用对象参数
struct UserOptions {
    name: string
    age: int
    email: string
    phone: string
}

var createUserWithOptions = func(options: UserOptions) User {
    // ...
}
```

### 4. 纯函数优先

```q
// 好：纯函数（无副作用）
var add = func(a: int, b: int) int {
    return a + b
}

// 避免：有副作用
var globalCount = 0
var increment = func() {
    globalCount += 1  // 修改全局状态
}
```

### 5. 默认参数合理化

```q
// 好：常用默认值
var connect = func(
    host: string = "localhost",
    port: int = 8080,
    timeout: int = 30
) {
    // ...
}

// 不好：没有实际意义的默认值
var process = func(value: int = 0) {
    // 0 可能不是合理的默认值
}
```

---

## 下一步

- 学习 [泛型](./泛型.md)
- 学习 [错误处理](./错误处理.md)
- 学习 [并发编程](./并发编程.md)
