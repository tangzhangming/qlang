# Q è¯­è¨€æ•™ç¨‹ - æ³›å‹

## ç›®å½•

1. [æ³›å‹æ¦‚è¿°](#æ³›å‹æ¦‚è¿°)
2. [æ³›å‹ç±»](#æ³›å‹ç±»)
3. [æ³›å‹ç»“æ„ä½“](#æ³›å‹ç»“æ„ä½“)
4. [æ³›å‹å‡½æ•°](#æ³›å‹å‡½æ•°)
5. [æ³›å‹æ¥å£](#æ³›å‹æ¥å£)
6. [ç±»å‹çº¦æŸ](#ç±»å‹çº¦æŸ)
7. [å®ç°çŠ¶æ€è¯´æ˜](#å®ç°çŠ¶æ€è¯´æ˜)

---

## æ³›å‹æ¦‚è¿°

æ³›å‹å…è®¸ç¼–å†™å¯ä»¥å¤„ç†å¤šç§ç±»å‹çš„ä»£ç ï¼Œæé«˜ä»£ç å¤ç”¨æ€§å’Œç±»å‹å®‰å…¨æ€§ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹

```q
// æ²¡æœ‰æ³›å‹ï¼šéœ€è¦ä¸ºæ¯ç§ç±»å‹å†™ä¸åŒçš„å®¹å™¨
class IntBox {
    func init(var value: int) {}
    func get() int { return this.value }
}

class StringBox {
    func init(var value: string) {}
    func get() string { return this.value }
}

// ä½¿ç”¨æ³›å‹ï¼šä¸€ä¸ªç±»æ”¯æŒæ‰€æœ‰ç±»å‹
class Box<T> {
    func init(var value: T) {}
    func get() T { return this.value }
}
```

### ç±»å‹å‚æ•°

ç±»å‹å‚æ•°ç”¨å°–æ‹¬å· `<>` è¡¨ç¤ºï¼Œé€šå¸¸ä½¿ç”¨å•ä¸ªå¤§å†™å­—æ¯ï¼š

- `T` - Typeï¼ˆç±»å‹ï¼‰
- `K` - Keyï¼ˆé”®ï¼‰
- `V` - Valueï¼ˆå€¼ï¼‰
- `E` - Elementï¼ˆå…ƒç´ ï¼‰
- `R` - Resultï¼ˆç»“æœï¼‰

---

## æ³›å‹ç±»

### åŸºæœ¬å®šä¹‰

```q
// å•ä¸ªç±»å‹å‚æ•°
class Box<T> {
    func init(var value: T) {}
    
    func get() T {
        return this.value
    }
    
    func set(value: T) {
        this.value = value
    }
}

// ä½¿ç”¨æ³›å‹ç±»
var intBox = new Box<int>(42)
println(intBox.get())  // 42

var strBox = new Box<string>("Hello")
println(strBox.get())  // "Hello"
```

### å¤šä¸ªç±»å‹å‚æ•°

```q
// ä¸¤ä¸ªç±»å‹å‚æ•°
class Pair<K, V> {
    func init(var first: K, var second: V) {}
    
    func getFirst() K {
        return this.first
    }
    
    func getSecond() V {
        return this.second
    }
    
    func swap() Pair<V, K> {
        return new Pair<V, K>(this.second, this.first)
    }
}

// ä½¿ç”¨
var pair = new Pair<string, int>("age", 25)
println(pair.getFirst())   // "age"
println(pair.getSecond())  // 25
```

### æ³›å‹ç±»ç»§æ‰¿

```q
// æ³›å‹ç±»å¯ä»¥ç»§æ‰¿
class Container<T> {
    func init(var items: T[]) {}
    
    func size() int {
        // ç®€åŒ–ç¤ºä¾‹
        return 0
    }
}

class Stack<T> extends Container<T> {
    func init(items: T[]) {
        super.init(items)
    }
    
    func push(item: T) {
        // æ·»åŠ å…ƒç´ 
    }
    
    func pop() T? {
        // ç§»é™¤å¹¶è¿”å›é¡¶éƒ¨å…ƒç´ 
        return null
    }
}
```

---

## æ³›å‹ç»“æ„ä½“

### åŸºæœ¬å®šä¹‰

```q
// æ³›å‹ç»“æ„ä½“
struct Pair<K, V> {
    first: K
    second: V
    
    func swap() Pair<V, K> {
        return Pair<V, K> {
            first: this.second,
            second: this.first
        }
    }
}

// ä½¿ç”¨
var p1 = Pair<int, string> {
    first: 1,
    second: "one"
}

var p2 = p1.swap()  // Pair<string, int>
```

### æ³›å‹ç»“æ„ä½“å®ç°æ¥å£

```q
interface Comparable<T> {
    func compareTo(other: T) int
}

struct Point<T> implements Comparable<Point<T>> {
    x: T
    y: T
    
    func compareTo(other: Point<T>) int {
        // ç®€åŒ–æ¯”è¾ƒé€»è¾‘
        return 0
    }
}
```

---

## æ³›å‹å‡½æ•°

### åŒ…çº§æ³›å‹å‡½æ•°

```q
// æ³›å‹å‡½æ•°å®šä¹‰
func identity<T>(x: T) T {
    return x
}

// ä½¿ç”¨ï¼ˆç±»å‹æ¨å¯¼ï¼‰
var intVal = identity(42)        // T = int
var strVal = identity("Hello")   // T = string

// æ˜¾å¼æŒ‡å®šç±»å‹å‚æ•°
var val = identity<int>(42)
```

### ç±»çš„æ³›å‹é™æ€æ–¹æ³•

```q
class Collections {
    // æ³›å‹é™æ€æ–¹æ³•
    static func swap<T>(a: T, b: T) (T, T) {
        return b, a
    }
    
    static func first<T>(arr: T[]) T? {
        if arr == [] {
            return null
        }
        return arr[0]
    }
    
    static func last<T>(arr: T[]) T? {
        // ç®€åŒ–ç¤ºä¾‹
        return null
    }
}

// ä½¿ç”¨
var x, y = Collections::swap<int>(10, 20)
var first = Collections::first<string>(["a", "b", "c"])
```

### å¤šä¸ªç±»å‹å‚æ•°

```q
class Utils {
    static func zip<T, U>(a: T[], b: U[]) Pair<T, U>[] {
        var result: Pair<T, U>[] = []
        // ç®€åŒ–é€»è¾‘
        return result
    }
    
    static func map<T, U>(arr: T[], f: func(T) U) U[] {
        var result: U[] = []
        for item in arr {
            // result.append(f(item))
        }
        return result
    }
}
```

---

## æ³›å‹æ¥å£

### åŸºæœ¬å®šä¹‰

```q
// æ³›å‹æ¥å£
interface Container<T> {
    func add(item: T)
    func remove(item: T) bool
    func contains(item: T) bool
    func size() int
}

// å®ç°æ³›å‹æ¥å£
class ArrayList<T> implements Container<T> {
    items: T[]
    
    func init() {
        this.items = []
    }
    
    func add(item: T) {
        // this.items.append(item)
    }
    
    func remove(item: T) bool {
        // ç§»é™¤é€»è¾‘
        return false
    }
    
    func contains(item: T) bool {
        // æ£€æŸ¥é€»è¾‘
        return false
    }
    
    func size() int {
        return 0  // ç®€åŒ–
    }
}
```

### å¤šä¸ªç±»å‹å‚æ•°çš„æ¥å£

```q
interface Map<K, V> {
    func put(key: K, value: V)
    func get(key: K) V?
    func remove(key: K) bool
    func keys() K[]
    func values() V[]
}

class HashMap<K, V> implements Map<K, V> {
    // å®ç°...
}
```

---

## ç±»å‹çº¦æŸ

**æ³¨æ„**ï¼šç±»å‹çº¦æŸè¯­æ³•å·²åœ¨è®¾è®¡ä¸­ï¼Œä½†å½“å‰ç‰ˆæœ¬å¯èƒ½å°šæœªå®Œå…¨å®ç°ã€‚

### åŸºæœ¬çº¦æŸ

```q
// T å¿…é¡»å®ç° Comparable æ¥å£
class Sorter {
    static func sort<T: Comparable<T>>(items: T[]) T[] {
        // æ’åºé€»è¾‘
        return items
    }
}
```

### å¤šä¸ªçº¦æŸ

```q
// T å¿…é¡»åŒæ—¶å®ç°å¤šä¸ªæ¥å£
class Processor {
    static func process<T: Comparable<T> + Printable>(item: T) {
        // å¯ä»¥è°ƒç”¨ Comparable å’Œ Printable çš„æ–¹æ³•
        // item.println()
        // item.compareTo(...)
    }
}
```

### where å­å¥

```q
// ä½¿ç”¨ where å­å¥è¡¨è¾¾å¤æ‚çº¦æŸ
class Converter {
    static func convert<T, U>(a: T, b: U) T
        where T: Comparable<T>, U: Printable {
        // çº¦æŸæ¡ä»¶ï¼š
        // - T å®ç° Comparable<T>
        // - U å®ç° Printable
        return a
    }
}
```

---

## å¸¸è§æ³›å‹æ¨¡å¼

### 1. å®¹å™¨/é›†åˆ

```q
class Stack<T> {
    items: T[]
    
    func init() {
        this.items = []
    }
    
    func push(item: T) {
        // this.items.append(item)
    }
    
    func pop() T? {
        // ç§»é™¤å¹¶è¿”å›é¡¶éƒ¨å…ƒç´ 
        return null
    }
    
    func peek() T? {
        // è¿”å›é¡¶éƒ¨å…ƒç´ ä½†ä¸ç§»é™¤
        return null
    }
    
    func isEmpty() bool {
        return this.items == []
    }
}

var intStack = new Stack<int>()
intStack.push(1)
intStack.push(2)
```

### 2. Result ç±»å‹

```q
// ç±»ä¼¼ Rust çš„ Result<T, E>
class Result<T, E> {
    isOk: bool
    value: T?
    error: E?
    
    func init(isOk: bool, value: T?, error: E?) {
        this.isOk = isOk
        this.value = value
        this.error = error
    }
    
    static func ok(value: T) Result<T, E> {
        return new Result<T, E>(true, value, null)
    }
    
    static func err(error: E) Result<T, E> {
        return new Result<T, E>(false, null, error)
    }
    
    func isOk() bool {
        return this.isOk
    }
    
    func isErr() bool {
        return !this.isOk
    }
    
    func unwrap() T {
        if !this.isOk {
            panic("Called unwrap on an Err value")
        }
        return this.value!
    }
}

// ä½¿ç”¨
var divide = func(a: int, b: int) Result<int, string> {
    if b == 0 {
        return Result::err("Division by zero")
    }
    return Result::ok(a / b)
}
```

### 3. Option ç±»å‹

```q
// ç±»ä¼¼ Rust çš„ Option<T>
class Option<T> {
    hasValue: bool
    value: T?
    
    func init(hasValue: bool, value: T?) {
        this.hasValue = hasValue
        this.value = value
    }
    
    static func some(value: T) Option<T> {
        return new Option<T>(true, value)
    }
    
    static func none() Option<T> {
        return new Option<T>(false, null)
    }
    
    func isSome() bool {
        return this.hasValue
    }
    
    func isNone() bool {
        return !this.hasValue
    }
    
    func unwrap() T {
        if !this.hasValue {
            panic("Called unwrap on None")
        }
        return this.value!
    }
    
    func unwrapOr(default: T) T {
        if this.hasValue {
            return this.value!
        }
        return default
    }
}
```

---

## å®Œæ•´ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šæ³›å‹é“¾è¡¨

```q
class Node<T> {
    func init(var value: T, var next: Node<T>?) {}
}

class LinkedList<T> {
    head: Node<T>?
    size: int
    
    func init() {
        this.head = null
        this.size = 0
    }
    
    func append(value: T) {
        var newNode = new Node<T>(value, null)
        
        if this.head == null {
            this.head = newNode
        } else {
            // æ‰¾åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹å¹¶æ·»åŠ 
            var current = this.head
            // éå†é€»è¾‘...
        }
        
        this.size += 1
    }
    
    func get(index: int) T? {
        if index < 0 || index >= this.size {
            return null
        }
        
        // éå†åˆ°æŒ‡å®šç´¢å¼•
        return null  // ç®€åŒ–
    }
    
    func getSize() int {
        return this.size
    }
}

// ä½¿ç”¨
var list = new LinkedList<int>()
list.append(1)
list.append(2)
list.append(3)
println(list.getSize())  // 3
```

### ç¤ºä¾‹ 2ï¼šæ³›å‹æ ‘

```q
class TreeNode<T> {
    func init(
        var value: T,
        var left: TreeNode<T>?,
        var right: TreeNode<T>?
    ) {}
}

class BinaryTree<T> {
    root: TreeNode<T>?
    
    func init() {
        this.root = null
    }
    
    func insert(value: T) {
        if this.root == null {
            this.root = new TreeNode<T>(value, null, null)
        } else {
            // æ’å…¥é€»è¾‘
        }
    }
    
    func contains(value: T) bool {
        // æœç´¢é€»è¾‘
        return false
    }
}
```

### ç¤ºä¾‹ 3ï¼šæ³›å‹å·¥å…·ç±»

```q
class Arrays {
    // æ•°ç»„åè½¬
    static func reverse<T>(arr: T[]) T[] {
        var result: T[] = []
        // åè½¬é€»è¾‘
        return result
    }
    
    // æŸ¥æ‰¾å…ƒç´ 
    static func indexOf<T>(arr: T[], target: T) int {
        for var i = 0; i < 0; i++ {  // ç®€åŒ–
            // if arr[i] == target {
            //     return i
            // }
        }
        return -1
    }
    
    // å¡«å……æ•°ç»„
    static func fill<T>(value: T, count: int) T[] {
        var result: T[] = []
        for var i = 0; i < count; i++ {
            // result.append(value)
        }
        return result
    }
}

// ä½¿ç”¨
var numbers = [1, 2, 3, 4, 5]
// var reversed = Arrays::reverse<int>(numbers)
// var zeros = Arrays::fill<int>(0, 10)
```

---

## å®ç°çŠ¶æ€è¯´æ˜

**é‡è¦æç¤º**ï¼šæ ¹æ®æµ‹è¯•ç”¨ä¾‹ `generic_test.q`ï¼ŒQ è¯­è¨€çš„æ³›å‹åŠŸèƒ½å½“å‰å¤„äºä»¥ä¸‹çŠ¶æ€ï¼š

### âœ… å·²æ”¯æŒï¼ˆè¯­æ³•å±‚é¢ï¼‰

1. **æ³›å‹ç±»è¯­æ³•**ï¼š`class Box<T> {}`
2. **æ³›å‹ç»“æ„ä½“è¯­æ³•**ï¼š`struct Pair<K, V> {}`
3. **æ³›å‹å‡½æ•°è¯­æ³•**ï¼š`func identity<T>(x: T) T {}`
4. **è§£æå’Œç±»å‹æ£€æŸ¥**ï¼šç¼–è¯‘å™¨å¯ä»¥è§£ææ³›å‹è¯­æ³•

### ğŸš§ å¯èƒ½æœªå®Œå…¨å®ç°

1. **ç±»å‹å‚æ•°å®ä¾‹åŒ–**ï¼šåˆ›å»ºæ³›å‹ç±»å‹çš„å®ä¾‹
2. **ç±»å‹çº¦æŸ**ï¼š`<T: Comparable<T>>` ç­‰çº¦æŸ
3. **ç±»å‹æ¨å¯¼**ï¼šè‡ªåŠ¨æ¨æ–­ç±»å‹å‚æ•°
4. **æ³›å‹æ–¹æ³•è°ƒç”¨**ï¼šè°ƒç”¨æ³›å‹ç±»å‹çš„æ–¹æ³•
5. **where å­å¥**ï¼šå¤æ‚çš„ç±»å‹çº¦æŸ

### ä½¿ç”¨å»ºè®®

åœ¨å½“å‰ç‰ˆæœ¬ä¸­ï¼š

```q
// å¯ä»¥å®šä¹‰æ³›å‹ç±»ï¼ˆç¼–è¯‘é€šè¿‡ï¼‰
class Box<T> {
    value: T
}

println("Generic class parsed!")

// ä½†å®é™…ä½¿ç”¨å¯èƒ½å—é™
// var box = new Box<int>()  // å¯èƒ½æ— æ³•å®ä¾‹åŒ–
```

**å»ºè®®**ï¼š

- äº†è§£æ³›å‹è¯­æ³•å’Œæ¦‚å¿µ
- å…³æ³¨é¡¹ç›®æ›´æ–°ï¼Œç­‰å¾…å®Œæ•´å®ç°
- æš‚æ—¶å¯ä½¿ç”¨ `unknown` ç±»å‹ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆ

---

## æ³›å‹æœ€ä½³å®è·µ

### 1. æœ‰æ„ä¹‰çš„ç±»å‹å‚æ•°å

```q
// å¥½ï¼šæ¸…æ™°çš„åç§°
class Map<Key, Value> {}
class Pair<First, Second> {}

// å¯ä»¥ï¼šçº¦å®šä¿—æˆçš„ç®€å†™
class Box<T> {}
class List<E> {}

// ä¸å¥½ï¼šæ— æ„ä¹‰çš„åç§°
class Container<A, B, C> {}
```

### 2. æœ€å°åŒ–ç±»å‹å‚æ•°

```q
// å¥½ï¼šåªç”¨å¿…è¦çš„ç±»å‹å‚æ•°
class Pair<T, U> {}

// ä¸å¥½ï¼šè¿‡å¤šç±»å‹å‚æ•°
class Complex<T, U, V, W, X> {}
```

### 3. åˆç†ä½¿ç”¨çº¦æŸ

```q
// å¥½ï¼šå¿…è¦æ—¶æ·»åŠ çº¦æŸ
class Sorter {
    static func sort<T: Comparable<T>>(items: T[]) T[] {
        // å¯ä»¥å®‰å…¨åœ°æ¯”è¾ƒå…ƒç´ 
    }
}

// é¿å…ï¼šè¿‡åº¦çº¦æŸ
class Container<T: Comparable<T> + Printable + Serializable> {
    // çº¦æŸå¤ªå¤šï¼Œé™åˆ¶äº†ä½¿ç”¨åœºæ™¯
}
```

---

## ä¸‹ä¸€æ­¥

- å­¦ä¹  [Trait](./Trait.md)
- å­¦ä¹  [é”™è¯¯å¤„ç†](./é”™è¯¯å¤„ç†.md)
- å­¦ä¹  [å‡½æ•°è¿›é˜¶](./å‡½æ•°è¿›é˜¶.md)
