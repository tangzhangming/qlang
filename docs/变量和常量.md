# Q 语言教程 - 变量和常量

## 目录

1. [变量声明](#变量声明)
2. [常量声明](#常量声明)
3. [类型推导](#类型推导)
4. [作用域规则](#作用域规则)
5. [变量遮蔽](#变量遮蔽)
6. [变量初始化](#变量初始化)
7. [最佳实践](#最佳实践)

---

## 变量声明

使用 `var` 关键字声明可变变量。

### 基本语法

```q
// 显式类型声明
var name: string = "Alice"
var age: int = 25
var score: f64 = 95.5
var active: bool = true
```

### 延迟初始化

变量可以先声明，稍后初始化，但必须在使用前赋值：

```q
var message: string

if someCondition {
    message = "Success"
} else {
    message = "Failed"
}

println(message)  // 这里必须已初始化
```

### 未初始化变量

```q
var count: int  // 声明但未初始化

// println(count)  // 错误！使用前必须初始化

count = 10
println(count)  // 正确：已初始化
```

---

## 常量声明

使用 `const` 关键字声明不可变常量。

### 基本语法

```q
// 常量必须在声明时初始化
const PI: f64 = 3.141592653589793
const MAX_SIZE: int = 1024
const APP_NAME: string = "MyApp"
```

### 类型推导

常量也支持类型推导：

```q
const PORT = 8080           // 推导为 int
const HOST = "localhost"    // 推导为 string
const ENABLED = true        // 推导为 bool
```

### 常量限制

```q
// 错误：常量必须在声明时初始化
// const VALUE: int

// 错误：常量不能重新赋值
const NUM = 42
// NUM = 100  // 编译错误
```

### 类常量

推荐使用类的静态常量来组织常量：

```q
class Config {
    static const MAX_USERS: int = 1000
    static const MIN_AGE: int = 18
    static const MAX_AGE: int = 100
    static const DEFAULT_TIMEOUT: int = 30
}

// 使用
if userCount > Config::MAX_USERS {
    println("Too many users")
}
```

---

## 类型推导

Q 语言支持自动类型推导，编译器可以根据初始值推断变量类型。

### 基本类型推导

```q
var i = 42              // 推导为 int
var f = 3.14            // 推导为 f64
var b = true            // 推导为 bool
var s = "Hello"         // 推导为 string
var c = 'A'             // 推导为 char
```

### 集合类型推导

```q
// 数组/切片推导
var numbers = [1, 2, 3, 4, 5]           // int[]
var names = ["Alice", "Bob", "Charlie"]  // string[]
var flags = [true, false, true]          // bool[]

// Map 推导
var ages = {
    "Alice": 25,
    "Bob": 30
}  // map[string]int

var config = {
    "host": "localhost",
    "port": "8080"
}  // map[string]string
```

### 函数类型推导

```q
// 函数参数和返回值类型推导
var add = func(a: int, b: int) int {
    return a + b
}  // func(int, int) int

// 闭包类型推导
var multiply = func(x: int, y: int) int {
    return x * y
}
```

### 显式类型 vs 推导

```q
// 推荐：显式指定类型（更清晰）
var count: int = 0
var message: string = "Hello"

// 也可以：类型推导（更简洁）
var count2 = 0
var message2 = "Hello"
```

---

## 作用域规则

Q 语言支持块级作用域。

### 块作用域

```q
var x = 10

if true {
    var y = 20      // y 的作用域仅在 if 块内
    println(x)      // 可以访问外部变量
    println(y)      // 20
}

// println(y)       // 错误：y 不在作用域内
```

### 函数作用域

```q
var global = 100

var myFunc = func() {
    var local = 200
    println(global)  // 可以访问全局变量
    println(local)   // 200
}

myFunc()
// println(local)    // 错误：local 不在作用域内
```

### 循环作用域

```q
for var i = 0; i < 5; i++ {
    var temp = i * 2
    println(temp)
}

// println(i)     // 错误：i 只在循环内可见
// println(temp)  // 错误：temp 只在循环内可见
```

### 嵌套作用域

```q
var outer = 10

if true {
    var middle = 20
    
    if true {
        var inner = 30
        println(outer)   // 可访问：10
        println(middle)  // 可访问：20
        println(inner)   // 可访问：30
    }
    
    // println(inner) // 错误：inner 不可见
}
```

---

## 变量遮蔽

**重要**：Q 语言不允许在同一函数内的不同作用域中声明同名变量。

### 禁止遮蔽

```q
var test = func() {
    var x = 10
    
    if true {
        // 错误！不允许遮蔽外层变量
        // var x = 20
        
        // 正确：修改外层变量
        x = 20
    }
    
    println(x)  // 20
}
```

### 不同函数可以有同名变量

```q
var func1 = func() {
    var x = 10
    println(x)
}

var func2 = func() {
    var x = 20  // 正确：不同函数
    println(x)
}

func1()  // 10
func2()  // 20
```

### 为什么禁止遮蔽

禁止变量遮蔽有助于：
1. 避免混淆和错误
2. 使代码更清晰
3. 减少命名冲突

```q
// 不好的做法（其他语言中）
var value = 10
if condition {
    var value = 20  // 遮蔽外层变量，容易混淆
    println(value)
}

// Q 语言的做法（更清晰）
var value = 10
if condition {
    var newValue = 20  // 使用不同名称
    println(newValue)
}
```

---

## 变量初始化

### 默认值

未显式初始化的变量有默认值（如果类型明确）：

```q
// 基本类型的默认值
// int, uint, i8~i64, u8~u64: 0
// f32, f64: 0.0
// bool: false
// string: ""
// 引用类型: null
```

### 字面量初始化

```q
// 整数
var decimal = 42
var negative = -100

// 浮点数
var pi = 3.14159
var scientific = 1.5e-10  // 科学记数法（可能未实现）

// 字符串
var str1 = "Hello"
var str2 = "Multi\nLine"

// 布尔
var flag1 = true
var flag2 = false

// 字符
var ch = 'A'
```

### 表达式初始化

```q
var sum = 10 + 20
var product = 5 * 6
var result = (100 / 2) + (50 * 3)

var greeting = "Hello" + " " + "World"

var isValid = (age >= 18) && (score > 60)
```

### 函数调用初始化

```q
var max = func(a: int, b: int) int {
    if a > b {
        return a
    }
    return b
}

var largest = max(10, 20)
println(largest)  // 20
```

---

## 多变量声明

### 多返回值接收

函数返回多个值时，可以同时声明多个变量：

```q
var divmod = func(a: int, b: int) (int, int) {
    return a / b, a % b
}

// 同时声明并接收两个值
var quotient, remainder = divmod(17, 5)
println(quotient)   // 3
println(remainder)  // 2
```

### 必须全部接收

```q
var getValues = func() (int, string, bool) {
    return 42, "Hello", true
}

// 必须接收所有返回值
var num, str, flag = getValues()
```

---

## 全局变量 vs 局部变量

### 包级变量

在函数外部声明的变量是包级变量：

```q
package myapp

// 包级变量（全局变量）
var globalCount: int = 0
const MAX_VALUE: int = 1000

var increment = func() {
    globalCount += 1
}

var getCount = func() int {
    return globalCount
}
```

### 局部变量

在函数内部声明的变量是局部变量：

```q
var calculate = func() int {
    var localSum = 0     // 局部变量
    var localCount = 10  // 局部变量
    
    for var i = 0; i < localCount; i++ {
        localSum += i
    }
    
    return localSum
}
```

---

## 变量生命周期

### 值类型变量

值类型变量在栈上分配，作用域结束时自动销毁：

```q
var process = func() {
    var x = 10          // 在栈上分配
    var arr: int[5]     // 数组在栈上分配
    
    // ... 使用 x 和 arr
}  // x 和 arr 自动销毁
```

### 引用类型变量

引用类型变量引用堆上的对象，由 GC 管理：

```q
var create = func() {
    var obj = new MyClass()  // 对象在堆上分配
    var slice = [1, 2, 3]    // 切片在堆上分配
    
    // ... 使用 obj 和 slice
}  // 变量销毁，但对象由 GC 回收
```

---

## 常见模式

### 计数器

```q
var counter = 0

var increment = func() {
    counter += 1
}

var reset = func() {
    counter = 0
}

var getCount = func() int {
    return counter
}
```

### 配置管理

```q
class Config {
    static const DEBUG: bool = true
    static const MAX_RETRIES: int = 3
    static const TIMEOUT: int = 30
    static const BASE_URL: string = "https://api.example.com"
    
    static var currentEnv: string = "production"
    
    static func isDebug() bool {
        return Config::DEBUG
    }
}
```

### 延迟初始化

```q
var getValue = func(condition: bool) int {
    var result: int
    
    if condition {
        result = 100
    } else {
        result = 200
    }
    
    return result
}
```

---

## 最佳实践

### 1. 优先使用 const

对于不会改变的值，使用 `const` 而非 `var`：

```q
// 好
const MAX_SIZE = 1024
const APP_NAME = "MyApp"

// 不好
var MAX_SIZE = 1024  // 应该用 const
```

### 2. 明确类型注解

对于公共 API 和复杂类型，显式指定类型：

```q
// 好：类型清晰
var userCount: int = 0
var config: map[string]string = {}

// 可以：简单情况下类型推导
var count = 0
```

### 3. 有意义的命名

使用描述性的变量名：

```q
// 好
var userAge = 25
var isValid = true
var totalScore = 100

// 不好
var x = 25
var flag = true
var n = 100
```

### 4. 最小作用域

在最小的作用域内声明变量：

```q
// 好：在需要的地方声明
if condition {
    var temp = calculate()
    process(temp)
}

// 不好：作用域过大
var temp: int
if condition {
    temp = calculate()
    process(temp)
}
```

### 5. 初始化时声明

尽量在声明时初始化：

```q
// 好
var count = 0

// 不好
var count: int
count = 0
```

### 6. 使用类常量组织

将相关常量组织在类中：

```q
// 好
class HttpStatus {
    static const OK: int = 200
    static const NOT_FOUND: int = 404
    static const SERVER_ERROR: int = 500
}

// 不太好：分散的常量
const HTTP_OK = 200
const HTTP_NOT_FOUND = 404
```

---

## 常见错误

### 1. 使用未初始化的变量

```q
var value: int

// println(value)  // 错误！未初始化

value = 10
println(value)     // 正确
```

### 2. 修改常量

```q
const MAX = 100

// MAX = 200  // 错误！常量不能修改
```

### 3. 变量遮蔽

```q
var x = 10

if true {
    // var x = 20  // 错误！不允许遮蔽
    x = 20         // 正确：修改外层变量
}
```

### 4. 作用域外访问

```q
if true {
    var temp = 10
}

// println(temp)  // 错误！temp 不在作用域内
```

---

## 完整示例

### 示例 1：配置系统

```q
class AppConfig {
    // 常量配置
    static const APP_NAME: string = "MyApp"
    static const VERSION: string = "1.0.0"
    static const MAX_USERS: int = 1000
    
    // 可变配置
    static var debugMode: bool = false
    static var logLevel: int = 1
    
    static func enableDebug() {
        AppConfig::debugMode = true
        AppConfig::logLevel = 3
    }
    
    static func getInfo() string {
        return AppConfig::APP_NAME + " v" + AppConfig::VERSION
    }
}

println(AppConfig::getInfo())
AppConfig::enableDebug()
```

### 示例 2：计数器类

```q
class Counter {
    func init(var count: int = 0) {}
    
    func increment() {
        this.count += 1
    }
    
    func decrement() {
        this.count -= 1
    }
    
    func reset() {
        this.count = 0
    }
    
    func getValue() int {
        return this.count
    }
}

var counter = new Counter()
counter.increment()
counter.increment()
println(counter.getValue())  // 2
```

### 示例 3：作用域演示

```q
var demonstrateScope = func() {
    var outer = "Outer"
    
    if true {
        var inner = "Inner"
        println(outer)  // 可访问外层变量
        println(inner)  // Inner
        
        for var i = 0; i < 3; i++ {
            var loop = "Loop " + i as string
            println(loop)
        }
    }
    
    // println(inner)  // 错误：不可访问
}

demonstrateScope()
```

---

## 下一步

- 学习 [运算符](./运算符.md)
- 学习 [类型系统进阶](./类型系统进阶.md)
- 学习 [函数进阶](./函数进阶.md)
