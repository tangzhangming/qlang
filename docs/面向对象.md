# Q 语言教程 - 面向对象

## 目录

1. [类的基础](#类的基础)
2. [构造函数](#构造函数)
3. [字段和属性](#字段和属性)
4. [方法](#方法)
5. [静态成员](#静态成员)
6. [继承](#继承)
7. [抽象类](#抽象类)
8. [接口](#接口)
9. [可见性](#可见性)
10. [this 和 super](#this-和-super)

---

## 类的基础

类是引用类型，分配在堆上，由 GC 管理内存。

### 基本定义

```q
class Person {
    // 类的成员
}
```

### 简单类示例

```q
class Dog {
    func speak() string {
        return "Woof!"
    }
}

var dog = new Dog()
println(dog.speak())  // 输出：Woof!
```

---

## 构造函数

构造函数用 `init` 方法定义，使用 `new` 关键字创建实例。

### 基本构造函数

```q
class Person {
    name: string
    age: int
    
    func init(name: string, age: int) {
        this.name = name
        this.age = age
    }
}

var person = new Person("Alice", 25)
```

### 构造函数参数属性提升

**重要特性**：在构造函数参数前加 `var`，可以自动将参数提升为类字段：

```q
class Person {
    // 使用 var 参数，自动创建字段
    func init(var name: string, var age: int) {
        // name 和 age 自动成为 this.name 和 this.age
        // 无需手动赋值！
        println("Person created with name: " + this.name)
    }
    
    func describe() {
        print("Name: ")
        println(this.name)
        print("Age: ")
        println(this.age)
    }
}

var p = new Person("Alice", 25)
p.describe()
// 输出：
// Person created with name: Alice
// Name: Alice
// Age: 25
```

这等价于传统写法：

```q
class Person {
    name: string
    age: int
    
    func init(name: string, age: int) {
        this.name = name
        this.age = age
    }
}
```

### 带可见性的参数属性提升

可以在 `var` 参数前添加可见性修饰符：

```q
class Employee {
    // public var name - 公开字段
    // private var salary - 私有字段
    func init(public var name: string, private var salary: int) {
        // 自动创建 public name 和 private salary 字段
    }
    
    func getSalary() int {
        return this.salary
    }
}

var emp = new Employee("Bob", 50000)
println(emp.name)  // 可访问：公开字段
// println(emp.salary)  // 错误：私有字段
println(emp.getSalary())  // 通过方法访问
```

### 构造函数限制

**重要**：Q 语言不支持构造函数重载，每个类只能有一个 `init` 方法。

```q
// 错误示例：不允许
class Point {
    func init() {
        // ...
    }
    
    // 错误！不能有多个 init
    func init(x: int, y: int) {
        // ...
    }
}
```

可以使用默认参数来实现类似重载的效果：

```q
class Point {
    func init(var x: int = 0, var y: int = 0) {
        // 可以无参调用：new Point()
        // 也可以带参调用：new Point(10, 20)
    }
}

var p1 = new Point()        // x=0, y=0
var p2 = new Point(10, 20)  // x=10, y=20
```

---

## 字段和属性

### 字段声明

```q
class Person {
    name: string
    age: int
    email: string
    
    func init(name: string, age: int) {
        this.name = name
        this.age = age
        this.email = ""
    }
}
```

### 字段初始化

字段可以在声明时初始化：

```q
class Counter {
    count: int = 0
    prefix: string = "Count: "
    
    func increment() {
        this.count += 1
    }
    
    func display() {
        println(this.prefix + this.count as string)
    }
}
```

### 字段访问

```q
class Person {
    func init(var name: string, var age: int) {}
}

var person = new Person("Alice", 25)

// 读取字段
println(person.name)  // Alice
println(person.age)   // 25

// 修改字段
person.name = "Bob"
person.age = 30
```

---

## 方法

### 实例方法

实例方法通过 `this` 访问当前对象：

```q
class Rectangle {
    func init(var width: int, var height: int) {}
    
    func area() int {
        return this.width * this.height
    }
    
    func perimeter() int {
        return 2 * (this.width + this.height)
    }
}

var rect = new Rectangle(10, 20)
println(rect.area())       // 200
println(rect.perimeter())  // 60
```

### 方法修改状态

```q
class BankAccount {
    func init(var balance: int) {}
    
    func deposit(amount: int) {
        this.balance += amount
    }
    
    func withdraw(amount: int) bool {
        if amount > this.balance {
            return false
        }
        this.balance -= amount
        return true
    }
    
    func getBalance() int {
        return this.balance
    }
}

var account = new BankAccount(1000)
account.deposit(500)
println(account.getBalance())  // 1500
account.withdraw(200)
println(account.getBalance())  // 1300
```

---

## 静态成员

静态成员属于类本身，而非实例。通过 `::` 访问。

### 静态方法

```q
class MathHelper {
    static func max(a: int, b: int) int {
        if a > b {
            return a
        }
        return b
    }
    
    static func min(a: int, b: int) int {
        if a < b {
            return a
        }
        return b
    }
}

// 通过类名调用静态方法
var maximum = MathHelper::max(10, 20)
var minimum = MathHelper::min(10, 20)

println(maximum)  // 20
println(minimum)  // 10
```

### 静态字段

```q
class Counter {
    static count: int = 0
    
    func init() {
        Counter::count += 1
    }
    
    static func getCount() int {
        return Counter::count
    }
}

var c1 = new Counter()
var c2 = new Counter()
var c3 = new Counter()

println(Counter::getCount())  // 3
```

### 静态常量

使用 `static const` 定义类常量：

```q
class Config {
    static const MAX_USERS: int = 1000
    static const APP_NAME: string = "MyApp"
    static const VERSION: string = "1.0.0"
}

println(Config::MAX_USERS)  // 1000
println(Config::APP_NAME)   // MyApp
```

---

## 继承

类可以继承另一个类，获得其所有字段和方法。

### 基本继承

```q
class Animal {
    func speak() string {
        return "..."
    }
}

class Dog extends Animal {
    // Dog 继承了 Animal 的 speak 方法
}

var dog = new Dog()
println(dog.speak())  // 输出：...
```

### 构造函数继承

子类构造函数必须调用父类构造函数：

```q
class Animal {
    func init(var name: string) {}
    
    func speak() string {
        return "..."
    }
}

class Dog extends Animal {
    func init(name: string, var breed: string) {
        super.init(name)  // 调用父类构造函数
    }
    
    func getBreed() string {
        return this.breed
    }
}

var dog = new Dog("Buddy", "Labrador")
println(dog.name)      // Buddy（继承自 Animal）
println(dog.getBreed()) // Labrador
```

### 方法重写

使用 `override` 关键字重写父类方法：

```q
class Animal {
    func speak() string {
        return "..."
    }
}

class Dog extends Animal {
    override func speak() string {
        return "Woof!"
    }
}

var dog = new Dog()
println(dog.speak())  // 输出：Woof!
```

**注意**：必须使用 `override` 关键字，否则会编译错误。

### 调用父类方法

使用 `super` 调用父类方法：

```q
class Animal {
    func speak() string {
        return "Some sound"
    }
    
    func describe() string {
        return "I am an animal"
    }
}

class Dog extends Animal {
    override func speak() string {
        return "Woof!"
    }
    
    override func describe() string {
        var base = super.describe()  // 调用父类方法
        return base + " and a dog"
    }
    
    func parentSpeak() string {
        return super.speak()  // 调用父类的 speak
    }
}

var dog = new Dog()
println(dog.speak())         // Woof!
println(dog.parentSpeak())   // Some sound
println(dog.describe())      // I am an animal and a dog
```

---

## 抽象类

抽象类不能直接实例化，用于定义子类必须实现的方法。

### 定义抽象类

使用 `abstract` 关键字：

```q
abstract class Shape {
    func init(var color: string) {}
    
    // 抽象方法：子类必须实现
    abstract func area() f64
    abstract func perimeter() f64
    
    // 具体方法：可以直接使用
    func getColor() string {
        return this.color
    }
    
    func describe() string {
        return "A " + this.color + " shape"
    }
}
```

### 实现抽象类

```q
class Circle extends Shape {
    func init(color: string, var radius: f64) {
        super.init(color)
    }
    
    // 必须实现所有抽象方法
    override func area() f64 {
        return 3.14159 * this.radius * this.radius
    }
    
    override func perimeter() f64 {
        return 2.0 * 3.14159 * this.radius
    }
}

class Rectangle extends Shape {
    func init(color: string, var width: f64, var height: f64) {
        super.init(color)
    }
    
    override func area() f64 {
        return this.width * this.height
    }
    
    override func perimeter() f64 {
        return 2.0 * (this.width + this.height)
    }
}

// 使用
var circle = new Circle("red", 5.0)
println(circle.describe())   // A red shape
println(circle.area())       // 78.53975

var rect = new Rectangle("blue", 10.0, 20.0)
println(rect.area())         // 200.0
```

### 抽象类限制

1. **不能实例化**：不能使用 `new` 创建抽象类实例
2. **构造函数不能是抽象的**：`init` 方法不能是 `abstract`
3. **抽象方法只能在抽象类中**：普通类不能有抽象方法

```q
abstract class Base {
    // 错误！构造函数不能是 abstract
    // abstract func init()
    
    func init() {
        // 可以有普通构造函数
    }
    
    abstract func doSomething()
}

// 错误！不能实例化抽象类
// var obj = new Base()
```

---

## 接口

接口定义行为契约，类和结构体都可以实现接口。

### 定义接口

```q
interface Drawable {
    func draw()
}

interface Resizable {
    func resize(width: int, height: int)
}
```

### 实现接口

```q
class Rectangle implements Drawable, Resizable {
    func init(var width: int, var height: int) {}
    
    func draw() {
        println("Drawing rectangle")
    }
    
    func resize(width: int, height: int) {
        this.width = width
        this.height = height
        println("Resizing rectangle")
    }
}

var rect = new Rectangle(100, 50)
rect.draw()
rect.resize(200, 100)
```

### 接口作为类型

```q
interface Printable {
    func print()
}

class Document implements Printable {
    func init(var content: string) {}
    
    func print() {
        println(this.content)
    }
}

class Image implements Printable {
    func init(var path: string) {}
    
    func print() {
        println("Printing image: " + this.path)
    }
}

// 使用接口类型
var printItem = func(item: Printable) {
    item.print()
}

var doc = new Document("Hello")
var img = new Image("/path/to/image.png")

printItem(doc)
printItem(img)
```

---

## 可见性

Q 语言采用 Kotlin 风格的可见性系统，默认为 `public`。

### 可见性级别

- **public**：所有地方可访问（默认）
- **internal**：同一模块内可见
- **private**：仅当前文件/类可见
- **protected**：当前类和子类可见

### 字段可见性

```q
class Person {
    public name: string = ""        // 公开（默认）
    private password: string = ""   // 私有
    protected age: int = 0          // 保护
    internal id: int = 0            // 模块内
    
    func init(name: string, password: string) {
        this.name = name
        this.password = password
    }
    
    func checkPassword(pwd: string) bool {
        return this.password == pwd  // 类内可访问私有字段
    }
}

var person = new Person("Alice", "secret123")
println(person.name)        // 可访问：public
// println(person.password) // 错误：private
```

### 方法可见性

```q
class BankAccount {
    private balance: int = 0
    
    func init(initialBalance: int) {
        this.balance = initialBalance
    }
    
    // 公开方法
    public func deposit(amount: int) {
        this.validateAmount(amount)
        this.balance += amount
    }
    
    // 私有方法
    private func validateAmount(amount: int) {
        if amount <= 0 {
            panic("Amount must be positive")
        }
    }
    
    // 保护方法
    protected func getBalance() int {
        return this.balance
    }
}
```

### 继承与可见性

```q
class Base {
    public publicField: int = 1
    protected protectedField: int = 2
    private privateField: int = 3
    
    protected func protectedMethod() {
        println("Protected method")
    }
}

class Derived extends Base {
    func test() {
        println(this.publicField)     // 可访问
        println(this.protectedField)  // 可访问
        // println(this.privateField) // 错误：私有字段不可访问
        
        this.protectedMethod()        // 可访问
    }
}
```

---

## this 和 super

### this 关键字

`this` 引用当前对象实例：

```q
class Person {
    func init(var name: string) {}
    
    func greet() {
        println("Hello, I am " + this.name)
    }
    
    func setName(name: string) {
        this.name = name  // 区分参数和字段
    }
}
```

### super 关键字

`super` 引用父类：

#### 调用父类构造函数

```q
class Animal {
    func init(var name: string) {}
}

class Dog extends Animal {
    func init(name: string, var breed: string) {
        super.init(name)  // 调用父类构造函数
    }
}
```

#### 调用父类方法

```q
class Animal {
    func speak() string {
        return "Some sound"
    }
}

class Dog extends Animal {
    override func speak() string {
        var base = super.speak()  // 调用父类方法
        return base + " and woof"
    }
}

var dog = new Dog()
println(dog.speak())  // Some sound and woof
```

---

## 完整示例

### 示例 1：银行账户系统

```q
abstract class Account {
    func init(var accountNumber: string, var balance: f64) {}
    
    abstract func calculateInterest() f64
    
    func deposit(amount: f64) {
        this.balance += amount
        println("Deposited: " + amount as string)
    }
    
    func withdraw(amount: f64) bool {
        if amount > this.balance {
            println("Insufficient balance")
            return false
        }
        this.balance -= amount
        println("Withdrawn: " + amount as string)
        return true
    }
    
    func getBalance() f64 {
        return this.balance
    }
}

class SavingsAccount extends Account {
    func init(accountNumber: string, balance: f64, var interestRate: f64) {
        super.init(accountNumber, balance)
    }
    
    override func calculateInterest() f64 {
        return this.balance * this.interestRate
    }
    
    func applyInterest() {
        var interest = this.calculateInterest()
        this.deposit(interest)
    }
}

class CheckingAccount extends Account {
    func init(accountNumber: string, balance: f64) {
        super.init(accountNumber, balance)
    }
    
    override func calculateInterest() f64 {
        return 0.0  // 无利息
    }
}

// 使用
var savings = new SavingsAccount("SA001", 1000.0, 0.05)
savings.applyInterest()
println(savings.getBalance())  // 1050.0

var checking = new CheckingAccount("CA001", 500.0)
checking.deposit(200.0)
checking.withdraw(100.0)
println(checking.getBalance())  // 600.0
```

### 示例 2：图形系统

```q
interface Drawable {
    func draw()
}

abstract class Shape implements Drawable {
    func init(var color: string) {}
    
    abstract func area() f64
    
    func getColor() string {
        return this.color
    }
}

class Circle extends Shape {
    func init(color: string, var radius: f64) {
        super.init(color)
    }
    
    override func area() f64 {
        return 3.14159 * this.radius * this.radius
    }
    
    override func draw() {
        println("Drawing a " + this.color + " circle")
    }
}

class Rectangle extends Shape {
    func init(color: string, var width: f64, var height: f64) {
        super.init(color)
    }
    
    override func area() f64 {
        return this.width * this.height
    }
    
    override func draw() {
        println("Drawing a " + this.color + " rectangle")
    }
}

// 使用
var shapes: Shape[] = []
// 注意：当前版本数组可能不支持多态，这里仅示意

var circle = new Circle("red", 5.0)
circle.draw()
println(circle.area())

var rect = new Rectangle("blue", 10.0, 20.0)
rect.draw()
println(rect.area())
```

---

## 最佳实践

1. **使用参数属性提升**：在构造函数中使用 `var` 参数简化代码
2. **优先使用接口**：面向接口编程，提高代码灵活性
3. **合理使用抽象类**：当有共享实现时使用抽象类，纯契约用接口
4. **最小可见性原则**：字段默认用 `private`，只在需要时开放
5. **明确标记 override**：重写方法时必须使用 `override` 关键字
6. **单一继承**：一个类只能继承一个父类，但可以实现多个接口
7. **构造函数调用顺序**：子类构造函数必须先调用 `super.init()`

---

## 下一步

- 学习 [基本类型](./基本类型.md)
- 学习 [控制结构](./控制结构.md)
- 学习 [结构体](./结构体.md)
