# Q 语言教程 - 错误处理

## 目录

1. [异常处理概述](#异常处理概述)
2. [try-catch 语句](#try-catch-语句)
3. [throw 语句](#throw-语句)
4. [finally 块](#finally-块)
5. [异常类型](#异常类型)
6. [自定义异常](#自定义异常)
7. [嵌套异常处理](#嵌套异常处理)
8. [panic 函数](#panic-函数)
9. [最佳实践](#最佳实践)

---

## 异常处理概述

Q 语言使用 `try-catch-finally` 机制处理运行时错误。异常是异常类的实例对象。

### 为什么需要异常处理

```q
// 没有异常处理
var divide = func(a: int, b: int) int {
    return a / b  // 如果 b 为 0 会崩溃
}

// 有异常处理
var safeDivide = func(a: int, b: int) int {
    try {
        if b == 0 {
            throw new ArithmeticException("Division by zero")
        }
        return a / b
    } catch (e: ArithmeticException) {
        println("Error: " + e.message)
        return 0
    }
}
```

---

## try-catch 语句

### 基本语法

```q
try {
    // 可能抛出异常的代码
    var result = riskyOperation()
} catch (e: Exception) {
    // 异常处理代码
    println("Caught exception: " + e.message)
}
```

### 完整示例

```q
println("=== Basic try/catch ===")

try {
    println("Inside try block")
    throw new Exception("Simple error message")
    println("This will not execute")
} catch (e: Exception) {
    println("Caught exception:")
    println(e.message)
}

println("Program continues")
```

输出：
```
=== Basic try/catch ===
Inside try block
Caught exception:
Simple error message
Program continues
```

### 按类型捕获异常

```q
try {
    throw new ArithmeticException("Division by zero")
} catch (e: ArithmeticException) {
    println("Arithmetic error: " + e.message)
} catch (e: Exception) {
    println("General error: " + e.message)
}
```

**注意**：更具体的异常类型应该放在前面，通用 `Exception` 放在最后。

---

## throw 语句

### 抛出异常

使用 `throw new` 抛出异常对象：

```q
throw new Exception("Error message")
throw new ArithmeticException("Division by zero")
throw new IOException("File not found")
```

### 在函数中抛出异常

```q
var validateAge = func(age: int) {
    if age < 0 {
        throw new IllegalArgumentException("Age cannot be negative")
    }
    
    if age > 150 {
        throw new IllegalArgumentException("Age too large")
    }
    
    println("Age is valid")
}

try {
    validateAge(-5)
} catch (e: IllegalArgumentException) {
    println("Validation error: " + e.message)
}
```

### 条件抛出

```q
var divide = func(a: int, b: int) int {
    if b == 0 {
        throw new ArithmeticException("Division by zero")
    }
    return a / b
}

try {
    var result = divide(10, 0)
    println(result)
} catch (e: ArithmeticException) {
    println("Error: " + e.message)
}
```

---

## finally 块

`finally` 块中的代码无论是否发生异常都会执行。

### try-catch-finally

```q
try {
    println("Try block")
    throw new IllegalArgumentException("Invalid input")
} catch (e: IllegalArgumentException) {
    println("Catch block:")
    println(e.message)
} finally {
    println("Finally block (always executes)")
}
```

输出：
```
Try block
Catch block:
Invalid input
Finally block (always executes)
```

### finally 在正常执行时也运行

```q
try {
    println("Try block (no exception)")
} catch (e: Exception) {
    println("Catch block (should not execute)")
} finally {
    println("Finally block (still executes)")
}
```

输出：
```
Try block (no exception)
Finally block (still executes)
```

### finally 用于清理资源

```q
var processFile = func(filename: string) {
    var file: File? = null
    
    try {
        file = openFile(filename)
        // 处理文件
        println("Processing file")
    } catch (e: IOException) {
        println("Error processing file: " + e.message)
    } finally {
        // 确保文件被关闭
        if file != null {
            closeFile(file)
            println("File closed")
        }
    }
}
```

---

## 异常类型

Q 语言提供以下内置异常类：

### 常见异常类型

| 异常类型 | 说明 | 使用示例 |
|---------|------|----------|
| `Exception` | 通用异常基类 | `throw new Exception("General error")` |
| `RuntimeException` | 运行时异常 | `throw new RuntimeException("Unexpected error")` |
| `IOException` | I/O 异常 | `throw new IOException("File not found")` |
| `NullPointerException` | 空指针异常 | `throw new NullPointerException("Null value")` |
| `IllegalArgumentException` | 非法参数异常 | `throw new IllegalArgumentException("Invalid input")` |
| `ArithmeticException` | 算术异常 | `throw new ArithmeticException("Division by zero")` |
| `IndexOutOfBoundsException` | 索引越界异常 | `throw new IndexOutOfBoundsException("Index 10 out of bounds")` |

### 使用示例

```q
// IOException
try {
    throw new IOException("File not found")
} catch (e: IOException) {
    println("IO error: " + e.message)
}

// ArithmeticException
try {
    throw new ArithmeticException("Division by zero")
} catch (e: ArithmeticException) {
    println("Math error: " + e.message)
}

// NullPointerException
try {
    throw new NullPointerException("Null value")
} catch (e: NullPointerException) {
    println("Null error: " + e.message)
}
```

---

## 自定义异常

可以通过继承 `Exception` 创建自定义异常类。

### 定义自定义异常

```q
class ValidationException extends Exception {
    public field: string
    
    func init(field: string, message: string) {
        super.init(message)
        this.field = field
    }
}

class NetworkException extends Exception {
    public statusCode: int
    
    func init(message: string, statusCode: int) {
        super.init(message)
        this.statusCode = statusCode
    }
}
```

### 使用自定义异常

```q
var validateEmail = func(email: string) {
    if email == "" {
        throw new ValidationException("email", "Email cannot be empty")
    }
    
    // 简单检查
    if !email.contains("@") {
        throw new ValidationException("email", "Invalid email format")
    }
}

try {
    validateEmail("")
} catch (e: ValidationException) {
    println("Validation error on field '" + e.field + "': " + e.message)
}
```

### 带错误码的异常

```q
class ApiException extends Exception {
    public code: int
    public details: string
    
    func init(message: string, code: int, details: string = "") {
        super.init(message)
        this.code = code
        this.details = details
    }
}

try {
    throw new ApiException("Request failed", 500, "Internal server error")
} catch (e: ApiException) {
    println("API Error [" + (e.code as string) + "]: " + e.message)
    if e.details != "" {
        println("Details: " + e.details)
    }
}
```

---

## 嵌套异常处理

### 嵌套 try-catch

```q
try {
    println("Outer try")
    
    try {
        println("Inner try")
        throw new NullPointerException("null value")
    } catch (e: NullPointerException) {
        println("Inner catch: " + e.message)
        
        // 在内层 catch 中重新抛出异常
        throw new RuntimeException("Re-thrown from inner")
    }
} catch (e: RuntimeException) {
    println("Outer catch: " + e.message)
}
```

输出：
```
Outer try
Inner try
Inner catch: null value
Outer catch: Re-thrown from inner
```

### 异常传播

```q
var level3 = func() {
    throw new Exception("Error from level 3")
}

var level2 = func() {
    level3()
}

var level1 = func() {
    level2()
}

try {
    level1()
} catch (e: Exception) {
    println("Caught at top level: " + e.message)
}
```

### 异常链（包装异常）

```q
class ServiceException extends Exception {
    public cause: Exception?
    
    func init(message: string, cause: Exception? = null) {
        super.init(message)
        this.cause = cause
    }
}

try {
    try {
        throw new IOException("Database connection failed")
    } catch (e: IOException) {
        // 包装底层异常
        throw new ServiceException("Failed to load user data", e)
    }
} catch (e: ServiceException) {
    println("Service error: " + e.message)
    if e.cause != null {
        println("Caused by: " + e.cause.message)
    }
}
```

---

## panic 函数

`panic` 是内置函数，用于触发不可恢复的错误，立即终止程序。

### 基本用法

```q
var criticalOperation = func() {
    var systemReady = false
    
    if !systemReady {
        panic("System not ready")
    }
    
    // 不会执行到这里
}

// criticalOperation()  // 会终止程序
```

### panic vs throw

| 特性 | throw | panic |
|------|-------|-------|
| 可恢复性 | 可以被 catch 捕获 | 不能被捕获 |
| 程序行为 | 继续执行 | 立即终止 |
| 使用场景 | 可预期的错误 | 致命错误/不应发生的情况 |

```q
// throw - 可恢复
try {
    throw new Exception("Recoverable error")
} catch (e: Exception) {
    println("Recovered from: " + e.message)
}
println("Program continues")

// panic - 不可恢复
// panic("Fatal error")  // 程序终止，后续代码不执行
```

### 何时使用 panic

```q
// 1. 程序初始化失败
func main() {
    var config = loadConfig()
    if config == null {
        panic("Failed to load configuration")
    }
}

// 2. 不应该到达的代码路径
var getType = func(value: int) string {
    match value {
        0 => return "zero"
        1 => return "one"
        _ => panic("Unexpected value: " + (value as string))
    }
}

// 3. 断言（开发时检查）
var assert = func(condition: bool, message: string) {
    if !condition {
        panic("Assertion failed: " + message)
    }
}
```

---

## 完整示例

### 示例 1：文件处理

```q
class FileNotFoundException extends IOException {
    func init(path: string) {
        super.init("File not found: " + path)
    }
}

var readFile = func(filename: string) string {
    if filename == "" {
        throw new IllegalArgumentException("Filename cannot be empty")
    }
    
    // 模拟文件读取
    if filename == "nonexistent.txt" {
        throw new FileNotFoundException(filename)
    }
    
    return "File contents"
}

var processFile = func(filename: string) {
    try {
        var content = readFile(filename)
        println("File content: " + content)
    } catch (e: FileNotFoundException) {
        println("File not found: " + e.message)
    } catch (e: IllegalArgumentException) {
        println("Invalid argument: " + e.message)
    } catch (e: Exception) {
        println("Unexpected error: " + e.message)
    } finally {
        println("Cleanup completed")
    }
}

processFile("nonexistent.txt")
```

### 示例 2：输入验证

```q
class ValidationException extends Exception {
    public field: string
    
    func init(field: string, message: string) {
        super.init(message)
        this.field = field
    }
}

class Validator {
    static func validateEmail(email: string) {
        if email == "" {
            throw new ValidationException("email", "Email cannot be empty")
        }
        
        if !email.contains("@") {
            throw new ValidationException("email", "Invalid email format")
        }
    }
    
    static func validateAge(age: int) {
        if age < 0 {
            throw new ValidationException("age", "Age cannot be negative")
        }
        
        if age > 150 {
            throw new ValidationException("age", "Age too large")
        }
    }
    
    static func validateUsername(username: string) {
        if username == "" {
            throw new ValidationException("username", "Username cannot be empty")
        }
        
        if username.length() < 3 {
            throw new ValidationException("username", "Username too short")
        }
    }
}

// 使用验证器
var registerUser = func(username: string, email: string, age: int) {
    try {
        Validator::validateUsername(username)
        Validator::validateEmail(email)
        Validator::validateAge(age)
        
        println("User registered successfully")
    } catch (e: ValidationException) {
        println("Validation failed on '" + e.field + "': " + e.message)
    }
}

registerUser("", "invalid-email", -5)
```

### 示例 3：数学运算

```q
class SafeMath {
    static func divide(a: int, b: int) int {
        if b == 0 {
            throw new ArithmeticException("Division by zero")
        }
        return a / b
    }
    
    static func sqrt(n: int) int {
        if n < 0 {
            throw new ArithmeticException("Cannot calculate sqrt of negative number")
        }
        // 平方根计算
        return n  // 简化
    }
    
    static func factorial(n: int) int {
        if n < 0 {
            throw new IllegalArgumentException("Factorial of negative number")
        }
        
        if n > 20 {
            throw new ArithmeticException("Result too large")
        }
        
        if n <= 1 {
            return 1
        }
        return n * SafeMath::factorial(n - 1)
    }
}

// 使用
try {
    var result1 = SafeMath::divide(10, 2)
    println(result1)  // 5
    
    var result2 = SafeMath::divide(10, 0)  // 抛出异常
} catch (e: ArithmeticException) {
    println("Math error: " + e.message)
}

try {
    var fact = SafeMath::factorial(5)
    println(fact)  // 120
} catch (e: Exception) {
    println("Error: " + e.message)
}
```

---

## 最佳实践

### 1. 使用具体的异常类型

```q
// 好：使用具体的异常类型
throw new ArithmeticException("Division by zero")
throw new NullPointerException("User cannot be null")

// 不好：总是使用通用 Exception
throw new Exception("Error")
```

### 2. 提供有意义的错误消息

```q
// 好：清晰的错误消息
throw new IOException("Cannot open file '/path/to/file.txt': Permission denied")

// 不好：模糊的错误消息
throw new IOException("Error")
```

### 3. 尽早失败

```q
// 好：参数验证在函数开头
var processUser = func(user: User?) {
    if user == null {
        throw new NullPointerException("User cannot be null")
    }
    
    // 继续处理...
}

// 不好：晚验证导致可能的部分执行
var processUser2 = func(user: User?) {
    // 一些操作...
    
    if user == null {  // 太晚了
        throw new NullPointerException("User cannot be null")
    }
}
```

### 4. 使用 finally 清理资源

```q
// 好：使用 finally 确保资源释放
var resource: Resource? = null
try {
    resource = acquireResource()
    useResource(resource)
} catch (e: Exception) {
    println("Error: " + e.message)
} finally {
    if resource != null {
        resource.release()  // 始终执行
    }
}
```

### 5. 不要忽略异常

```q
// 不好：空的 catch 块
try {
    riskyOperation()
} catch (e: Exception) {
    // 什么都不做 - 隐藏了错误！
}

// 好：至少记录异常
try {
    riskyOperation()
} catch (e: Exception) {
    println("Operation failed: " + e.message)
}
```

### 6. 按从具体到通用的顺序捕获

```q
// 好：具体异常在前
try {
    operation()
} catch (e: FileNotFoundException) {
    // 处理文件未找到
} catch (e: IOException) {
    // 处理其他 IO 错误
} catch (e: Exception) {
    // 处理所有其他异常
}

// 不好：通用异常在前（具体异常永远不会被捕获）
try {
    operation()
} catch (e: Exception) {
    // 捕获所有异常
} catch (e: IOException) {  // 永远不会执行！
    // ...
}
```

---

## 错误处理模式

### 1. 默认值模式

```q
var getConfigValue = func(key: string) string {
    try {
        return readConfig(key)
    } catch (e: Exception) {
        println("Using default value for " + key)
        return "default"
    }
}
```

### 2. 重试模式

```q
var retryOperation = func(maxAttempts: int) bool {
    for attempt in 0..maxAttempts {
        try {
            performOperation()
            return true
        } catch (e: Exception) {
            println("Attempt " + (attempt as string) + " failed: " + e.message)
            
            if attempt == maxAttempts - 1 {
                println("All attempts failed")
                return false
            }
        }
    }
    return false
}
```

### 3. 回退模式

```q
var getData = func() Data {
    try {
        return getFromPrimarySource()
    } catch (e: Exception) {
        println("Primary source failed, trying backup")
        
        try {
            return getFromBackupSource()
        } catch (e2: Exception) {
            println("Backup also failed, using cache")
            return getFromCache()
        }
    }
}
```

### 4. 转换异常模式

```q
class DataService {
    func getData() Data {
        try {
            return fetchFromDatabase()
        } catch (e: SQLException) {
            // 转换为更高层的异常
            throw new ServiceException("Failed to retrieve data", e)
        }
    }
}
```

---

## 下一步

- 学习 [并发编程](./并发编程.md)
- 学习 [类型系统进阶](./类型系统进阶.md)
- 学习 [函数进阶](./函数进阶.md)
