# Q 语言教程 - 类型系统进阶

## 目录

1. [类型转换](#类型转换)
2. [类型检查](#类型检查)
3. [可空类型](#可空类型)
4. [类型别名](#类型别名)
5. [类型推导进阶](#类型推导进阶)
6. [多态与类型](#多态与类型)

---

## 类型转换

### as 运算符

使用 `as` 进行显式类型转换：

```q
// 整数类型转换
var a: i32 = 100
var b: i64 = a as i64      // 安全：扩展转换
var c: i8 = a as i8        // 可能溢出

// 浮点类型转换
var f: f64 = 3.14
var g: f32 = f as f32      // 缩小精度

// 整数与浮点转换
var int_val = 42
var float_val = int_val as f64    // 42.0

var f2 = 3.9
var i2 = f2 as int                // 3（截断）
```

### 数值类型转换

#### 整数扩展转换

```q
// 小类型到大类型（安全）
var i8_val: i8 = 100
var i16_val: i16 = i8_val as i16    // 100
var i32_val: i32 = i16_val as i32   // 100
var i64_val: i64 = i32_val as i64   // 100
```

#### 整数缩小转换

```q
// 大类型到小类型（可能溢出）
var large: i32 = 1000
var small: i8 = large as i8   // 溢出（i8 范围：-128 到 127）

// 建议先检查范围
var safe_convert = func(val: i32) i8 {
    if val < -128 || val > 127 {
        panic("Value out of range for i8")
    }
    return val as i8
}
```

#### 有符号与无符号转换

```q
var signed: i32 = -10
var unsigned: u32 = signed as u32   // 补码表示，结果是大整数

var u: u32 = 100
var s: i32 = u as i32               // 100
```

### 浮点与整数转换

```q
// 整数到浮点（可能丢失精度）
var int_val = 123456789
var float_val = int_val as f32      // 可能不精确

// 浮点到整数（截断小数部分）
var f = 3.99
var i = f as int                    // 3（不是 4）

var f2 = -2.5
var i2 = f2 as int                  // -2
```

### 类型转换链

```q
var start: i8 = 100
var middle: i32 = start as i32
var end: f64 = middle as f64

// 或者直接链式转换
var result = (start as i32) as f64
```

---

## 类型检查

### is 运算符

使用 `is` 检查值的类型：

```q
var value: unknown = 42

// 基本类型检查
if value is int {
    println("It's an integer")
}

if value is string {
    println("It's a string")
}

if value is bool {
    println("It's a boolean")
}
```

### 类检查

```q
class Animal {}
class Dog extends Animal {}

var obj: Animal = new Dog()

if obj is Dog {
    println("It's a Dog")
}

if obj is Animal {
    println("It's an Animal")  // 也会匹配（Dog 是 Animal）
}
```

### match 中的类型模式

```q
var value: unknown = "Hello"

match value {
    x: int => {
        println("Integer: " + x as string)
    }
    s: string => {
        println("String: " + s)
    }
    b: bool => {
        println("Boolean: " + b as string)
    }
    _ => {
        println("Unknown type")
    }
}
```

---

## 可空类型

### 声明可空类型

在类型后加 `?` 表示可空：

```q
var name: string? = null
var age: int? = null
var score: f64? = null
```

### null 赋值

```q
var value: int? = 42
value = null        // 可以赋值为 null

// 非空类型不能赋值为 null
var count: int = 10
// count = null     // 错误！
```

### 可空类型判断

```q
var name: string? = "Alice"

// 检查是否为 null
if name != null {
    println("Name is: " + name)
}

if name == null {
    println("Name is null")
}
```

### 使用默认值

当值可能为 null 时提供默认值：

```q
var name: string? = null
var displayName: string

// 方式 1：if-else
if name != null {
    displayName = name
} else {
    displayName = "Anonymous"
}

// 方式 2：在实际使用中处理
var greeting = func(name: string?) {
    if name != null {
        println("Hello, " + name)
    } else {
        println("Hello, Anonymous")
    }
}
```

---

## 类型别名

### type 关键字

使用 `type` 创建类型别名：

```q
// 基本类型别名
type UserId = i64
type Score = f64
type Name = string

// 使用别名
var id: UserId = 12345
var playerScore: Score = 95.5
var userName: Name = "Alice"
```

### 函数类型别名

```q
// 函数类型别名
type BinaryOp = func(int, int) int
type Predicate = func(int) bool
type Handler = func(string) void

// 使用别名
var add: BinaryOp = func(a: int, b: int) int {
    return a + b
}

var isPositive: Predicate = func(n: int) bool {
    return n > 0
}
```

### 集合类型别名

```q
type IntList = int[]
type StringMap = map[string]string
type UserMap = map[i64]User

// 使用别名
var numbers: IntList = [1, 2, 3]
var config: StringMap = {
    "host": "localhost",
    "port": "8080"
}
```

---

## 类型推导进阶

### 函数返回类型推导

```q
// 简单返回类型推导
var getNumber = func() int {
    return 42
}

// 复杂类型推导
var createUser = func(name: string, age: int) {
    // 返回类型可以推导，但建议显式指定
    return new User(name, age)
}
```

### 泛型上下文中的类型推导

```q
// 泛型函数（当前版本可能仅语法支持）
func identity<T>(x: T) T {
    return x
}

// 调用时可以推导类型参数
var result = identity(42)        // T 推导为 int
var str = identity("Hello")      // T 推导为 string
```

### 集合字面量推导

```q
// 数组类型推导
var numbers = [1, 2, 3]          // int[]
var names = ["Alice", "Bob"]      // string[]

// Map 类型推导
var ages = {
    "Alice": 25,
    "Bob": 30
}  // map[string]int

// 空集合需要类型注解
var empty: int[] = []
var emptyMap: map[string]int = {}
```

---

## 多态与类型

### 接口类型

```q
interface Drawable {
    func draw()
}

class Circle implements Drawable {
    func init(var radius: f64) {}
    
    func draw() {
        println("Drawing circle")
    }
}

class Rectangle implements Drawable {
    func init(var width: f64, var height: f64) {}
    
    func draw() {
        println("Drawing rectangle")
    }
}

// 接口类型可以引用任何实现该接口的对象
var shape: Drawable = new Circle(5.0)
shape.draw()

shape = new Rectangle(10.0, 20.0)
shape.draw()
```

### 继承与类型

```q
class Animal {
    func speak() string {
        return "..."
    }
}

class Dog extends Animal {
    override func speak() string {
        return "Woof!"
    }
}

// 子类对象可以赋值给父类类型变量
var animal: Animal = new Dog()
println(animal.speak())  // "Woof!"（调用子类方法）
```

### 类型兼容性

```q
class Base {}
class Derived extends Base {}

var base: Base = new Derived()  // 正确：子类可赋值给父类

// 反之需要显式转换（可能在运行时失败）
var derived: Derived
// derived = base  // 错误：需要显式转换
```

---

## typeof 运算符

`typeof` 用于获取类型信息（用于反射）：

```q
var value = 42

// 获取类型信息
var typeInfo = typeof(value)
println(typeInfo)  // 输出类型信息

// 获取类的类型信息
class User {}
var userType = typeof(User)
```

---

## sizeof 运算符

`sizeof` 获取类型的大小（字节）：

```q
// 基本类型大小
var size1 = sizeof(int)     // 平台相关（4 或 8）
var size2 = sizeof(i32)     // 4
var size3 = sizeof(i64)     // 8
var size4 = sizeof(f64)     // 8
var size5 = sizeof(bool)    // 1

println(size1)
println(size2)
```

---

## 完整示例

### 示例 1：类型安全的容器

```q
class Container {
    value: unknown
    
    func init(var value: unknown) {}
    
    func get() unknown {
        return this.value
    }
    
    func set(value: unknown) {
        this.value = value
    }
    
    func getAsInt() int? {
        if this.value is int {
            return this.value as int
        }
        return null
    }
    
    func getAsString() string? {
        if this.value is string {
            return this.value as string
        }
        return null
    }
}

var container = new Container(42)

var intVal = container.getAsInt()
if intVal != null {
    println("Integer value: " + intVal as string)
}

container.set("Hello")
var strVal = container.getAsString()
if strVal != null {
    println("String value: " + strVal)
}
```

### 示例 2：数值转换工具

```q
class NumberConverter {
    static func toInt(value: f64) int {
        return value as int
    }
    
    static func toFloat(value: int) f64 {
        return value as f64
    }
    
    static func safeToI8(value: int) i8? {
        if value < -128 || value > 127 {
            return null
        }
        return value as i8
    }
    
    static func round(value: f64) int {
        if value >= 0.0 {
            return (value + 0.5) as int
        } else {
            return (value - 0.5) as int
        }
    }
}

var f = 3.14
var i = NumberConverter::toInt(f)
println(i)  // 3

var rounded = NumberConverter::round(3.7)
println(rounded)  // 4

var small = NumberConverter::safeToI8(100)
if small != null {
    println("Converted: " + small as string)
}
```

### 示例 3：多态形状系统

```q
interface Shape {
    func area() f64
}

class Circle implements Shape {
    func init(var radius: f64) {}
    
    func area() f64 {
        return 3.14159 * this.radius * this.radius
    }
}

class Rectangle implements Shape {
    func init(var width: f64, var height: f64) {}
    
    func area() f64 {
        return this.width * this.height
    }
}

var calculateTotalArea = func(shapes: Shape[]) f64 {
    var total = 0.0
    for shape in shapes {
        total += shape.area()
    }
    return total
}

// 使用（注意：当前版本可能不支持多态数组）
// var shapes: Shape[] = []
// shapes.append(new Circle(5.0))
// shapes.append(new Rectangle(10.0, 20.0))
// println(calculateTotalArea(shapes))
```

---

## 类型系统最佳实践

### 1. 明确类型转换

总是使用 `as` 显式转换类型：

```q
// 好
var f = 3.14
var i = f as int

// 避免依赖隐式转换
```

### 2. 使用类型别名

为复杂类型创建有意义的别名：

```q
// 好
type UserId = i64
type UserMap = map[UserId]User

var users: UserMap = {}

// 不太好
var users: map[i64]User = {}
```

### 3. 类型检查先于转换

使用 `is` 检查后再转换：

```q
// 好
if value is int {
    var num = value as int
    // 使用 num
}

// 避免盲目转换（可能失败）
```

### 4. 处理可空类型

始终检查 null：

```q
// 好
var name: string? = getName()
if name != null {
    println(name)
} else {
    println("No name")
}

// 不好（可能崩溃）
// println(name)  // 如果是 null 会出错
```

### 5. 接口优于具体类

函数参数和返回值优先使用接口类型：

```q
// 好
var process = func(shape: Shape) f64 {
    return shape.area()
}

// 不太好（限制了灵活性）
var process = func(circle: Circle) f64 {
    return circle.area()
}
```

---

## 常见错误

### 1. 类型不匹配

```q
var x: int = "Hello"  // 错误！类型不匹配
```

### 2. 未检查 null

```q
var name: string? = null
// println(name.length())  // 错误！可能是 null
```

### 3. 溢出转换

```q
var large: i32 = 1000
var small: i8 = large as i8  // 溢出！
```

### 4. 精度丢失

```q
var precise = 1234567890
var imprecise = precise as f32  // 可能丢失精度
```

---

## 下一步

- 学习 [泛型](./泛型.md)
- 学习 [函数进阶](./函数进阶.md)
- 学习 [错误处理](./错误处理.md)
