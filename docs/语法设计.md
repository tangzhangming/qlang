# MyLang 语法设计文档

## 基本目标

- **完全的静态类型**：编译时确定所有类型
- **运行在自己的虚拟机上**：跨平台执行
- **GC 垃圾回收**：自动内存管理
- **纯 OOP 组织**：没有全局函数，所有代码必须在类/结构体中

---

## 注释

```
// 单行注释

/*
   多行注释
   可以跨越多行
*/

/// 文档注释（用于生成API文档）
/// @param name 参数说明
/// @return 返回值说明
```

---

## 关键字

```
// 声明
var const fn struct class interface trait enum type

// 可见性
pub priv prot

// 类型
int uint i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 
bool byte char string unknown dynamic

// 控制流
if else for break continue return match go

// 面向对象
new this super extends implements use abstract static override

// 其他
true false null import package as in is try catch finally throw
make default sizeof typeof panic
```

---

## 类型系统

### 原始类型

```
// 整型（有符号）
int     // 平台相关：32位系统为i32，64位系统为i64
i8      // 8位有符号整数  [-128, 127]
i16     // 16位有符号整数 [-32768, 32767]
i32     // 32位有符号整数
i64     // 64位有符号整数

// 整型（无符号）
uint    // 平台相关：32位系统为u32，64位系统为u64
u8      // 8位无符号整数  [0, 255]
u16     // 16位无符号整数 [0, 65535]
u32     // 32位无符号整数
u64     // 64位无符号整数

// 浮点型
f32     // 32位浮点数（单精度）
f64     // 64位浮点数（双精度）

// 其他基本类型
bool    // 布尔类型：true 或 false
byte    // u8 的别名
char    // Unicode 码点（4字节，等同于 u32）
string  // 字符串（引用类型，不可变）
```

### 复合类型

```
// 数组（固定长度，值类型）
int[10]

// 切片（动态长度，引用类型）
int[]

// Map（引用类型）
map[K]V

// 函数/闭包类型
fn(int, string) bool

// 指针（受限使用，主要用于底层交互）
*int
```

### 特殊类型

```
unknown  // 安全的顶类型，可接收任何值，使用前必须进行类型检查
dynamic  // 跳过编译时类型检查，运行时动态解析。谨慎使用！
null     // 空值，只能赋给可空类型
```

### 可空类型

```
// 在类型后加 ? 表示可空
var name:string? = null
var age:int? = null

// 非空断言（确定不为null时使用，为null会抛异常）
var len:int = name!.length()

// 安全调用（为null时返回null）
var len:int? = name?.length()

// 空值合并（为null时使用默认值）
var displayName:string = name ?? "Anonymous"
```

### 类型转换与检查

```
// 显式类型转换（基本类型之间）
var a:i32 = 100
var b:i64 = a as i64      // 安全转换
var c:i8 = a as! i8       // 强制转换（可能溢出，失败抛异常）

// 类型检查
if value is string {
    // value 在此作用域自动推断为 string
}

// 类型断言（引用类型）
var obj:unknown = getValue()
var str:string? = obj as string?   // 安全转换，失败返回 null
var str2:string = obj as! string   // 强制转换，失败抛异常
```

### 类型别名

```
// 创建类型别名
type UserId = i64
type Handler = fn(Request) Response
type StringMap = map[string]string

// 使用
var id:UserId = 12345
var handlers:Handler[] = []
```

---

## 变量与常量

### 变量声明

```
// 显式类型
var message:string = "hello!"
var isOk:bool = true
var count:int = 0

// 类型推导
var foo = 100           // 推导为 int
var pi = 3.14           // 推导为 f64
var name = "Alice"      // 推导为 string

// 可空类型
var nickname:string? = null

// 延迟初始化（必须在使用前赋值）
var data:string
if condition {
    data = "A"
} else {
    data = "B"
}
```

### 常量声明

```
// 常量必须在声明时初始化，且值在编译时确定
const PI:f64 = 3.14159265358979
const MAX_SIZE:int = 1024
const APP_NAME = "MyApp"    // 类型推导

// 常量推荐用类的静态常量组织（见类章节）
```

### 作用域规则

```
// 支持块级作用域
// 不支持变量遮蔽：同一函数内不允许同名变量，即使在不同作用域

fn example() {
    var x:int = 10
    if true {
        // var x:int = 20    // 错误！不允许遮蔽外层变量
        var y:int = 20       // 正确，y 是新变量
        x = 30               // 正确，修改外层 x
    }
}
```

---

## 字符串

### 基本特性

```
// string 是引用类型，但不可变（Immutable）
// 任何"修改"操作都会返回新字符串

var s1:string = "Hello"
var s2:string = s1          // s2 和 s1 指向同一内存（高效）
var s3:string = s1 + " World"   // 创建新字符串
```

### 单引号与双引号

```
// 单引号：原样字符串，不解析插值，性能更好
var s1:string = 'hello ${name}'    // 输出: hello ${name}（原样保留）
var path:string = 'C:\Users\test'  // 不需要转义反斜杠

// 双引号：支持插值和转义
var s2:string = "hello ${name}"    // 输出: hello Alice（解析变量）
var s3:string = "line1\nline2"     // 支持转义字符

// 多行字符串（三引号，支持插值）
var html:string = """
    <html>
        <body>
            <h1>Hello, ${name}!</h1>
        </body>
    </html>
"""

// 多行原样字符串（三单引号，不插值）
var raw:string = '''
    SELECT * FROM users
    WHERE name = '${name}'
'''
```

### 字符串操作

```
var s:string = "Hello, World!"

// 常用方法
s.length()              // 长度（字符数）
s.byteLength()          // 字节长度（UTF-8编码）
s.isEmpty()             // 是否为空
s.contains("World")     // 是否包含子串
s.startsWith("Hello")   // 是否以指定前缀开头
s.endsWith("!")         // 是否以指定后缀结尾
s.indexOf("o")          // 查找子串位置，不存在返回 -1
s.substring(0, 5)       // 截取子串 "Hello"
s.replace("World", "MyLang")  // 替换
s.split(",")            // 分割为数组
s.trim()                // 去除首尾空白
s.toUpper()             // 转大写
s.toLower()             // 转小写

// 索引访问（返回 char）
var c:char = s[0]       // 'H'

// 遍历字符
for c in s {
    // c 是 char 类型
}

// 遍历字符和索引
for i, c in s {
    // i 是索引，c 是 char
}
```

### StringBuilder（可变字符串构建）

```
// 高效拼接大量字符串
var sb = new StringBuilder()
sb.append("Hello")
sb.append(", ")
sb.append("World")
var result:string = sb.toString()   // "Hello, World"

// 链式调用
var result2:string = new StringBuilder()
    .append("Name: ")
    .append(name)
    .append("\n")
    .toString()
```

---

## 数组与切片

### 数组（固定长度）

```
// 声明数组（值类型，分配在栈上）
var names:string[3]                              // 未初始化
var scores:int[5] = [90, 85, 78, 92, 88]        // 初始化
var flags:bool[3] = [true, false, true]

// 自动推断长度
var numbers:int[...] = [1, 2, 3, 4, 5]          // 长度为5

// 类型推导
var items = [1, 2, 3]                            // int[3]

// 二维数组
var matrix:int[3][3] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

// 访问元素
var first:int = scores[0]
scores[0] = 95

// 获取长度
var len:int = scores.length
```

### 切片（动态长度）

```
// 声明切片（引用类型）
var ids:int[]                                    // null 切片
var ids2:int[] = []                              // 空切片
var ids3:int[] = [1, 2, 3, 4, 5]                // 初始化

// 使用 make 创建
var slice1 = make(int[], 3)                      // 长度3，容量3
var slice2 = make(int[], 3, 10)                  // 长度3，容量10

// 从数组创建切片
var arr:int[5] = [1, 2, 3, 4, 5]
var s1:int[] = arr[:]                            // 全部元素
var s2:int[] = arr[1:4]                          // 索引1到3
var s3:int[] = arr[:3]                           // 索引0到2
var s4:int[] = arr[2:]                           // 索引2到末尾

// 切片操作（OOP 风格）
slice1.length                                    // 当前长度
slice1.capacity                                  // 当前容量
slice1.append(100)                               // 追加元素
slice1.appendAll([200, 300])                     // 追加多个元素
slice1.insert(0, 50)                             // 在指定位置插入
slice1.remove(0)                                 // 移除指定位置元素
slice1.clear()                                   // 清空
slice1.copy()                                    // 复制切片

// 遍历
for item in slice1 {
    // item
}

for i, item in slice1 {
    // i: 索引, item: 值
}
```

---

## Map

```
// 声明 Map（引用类型）
var userAges:map[string]int                      // null map
var scores:map[string]int = {}                   // 空 map

// 使用 make 创建
var cache = make(map[string]int)                 // 默认容量
var cache2 = make(map[string]int, 100)           // 指定初始容量

// 字面量初始化
var fruits:map[string]int = {
    "apple": 10,
    "banana": 20,
    "orange": 15
}

// 类型推导
var config = {
    "host": "localhost",
    "port": "8080"
}   // map[string]string

// 基本操作（OOP 风格）
fruits["grape"] = 25                             // 添加/修改
var count:int = fruits["apple"]                  // 获取（不存在返回默认值0）

// 安全获取
var value:int? = fruits.get("apple")             // 不存在返回 null

// 检查是否存在
if fruits.has("apple") {
    // ...
}

// 删除
fruits.remove("banana")

// 获取所有键/值
var keys:string[] = fruits.keys()
var values:int[] = fruits.values()

// 遍历
for key, value in fruits {
    // key, value
}

for key in fruits.keys() {
    // 只遍历键
}

// 其他方法
fruits.length                                    // 键值对数量
fruits.isEmpty()                                 // 是否为空
fruits.clear()                                   // 清空
```

---

## 控制结构

### if 语句

```
// 基本形式（括号可选）
if condition {
    // ...
}

if condition {
    // ...
} else {
    // ...
}

if condition1 {
    // ...
} else if condition2 {
    // ...
} else {
    // ...
}

// if 表达式（返回值）
var max:int = if a > b { a } else { b }

// 带初始化语句
if var result = compute(); result > 0 {
    // result 仅在此作用域可用
}
```

### for 循环

```
// C 风格循环
for var i:int = 0; i < 10; i++ {
    // ...
}

// 条件循环（代替 while）
for condition {
    // 当 condition 为 true 时循环
}

// 无限循环
for {
    // 无限循环，需要 break 退出
    if done {
        break
    }
}

// 范围循环
for i in 0..10 {          // 0 到 9（不含10）
    // ...
}

for i in 0..=10 {         // 0 到 10（含10）
    // ...
}

// 反向范围
for i in 10..0 {          // 10 到 1
    // ...
}

// 带步长
for i in (0..100).step(2) {   // 0, 2, 4, ..., 98
    // ...
}

// 迭代集合
for item in array {
    // item
}

for i, item in array {
    // i: 索引, item: 值
}

for key, value in map {
    // key, value
}
```

### break 和 continue

```
// 基本用法
for i in 0..10 {
    if i == 5 {
        break       // 退出循环
    }
    if i % 2 == 0 {
        continue    // 跳过本次迭代
    }
}

// 带标签（用于嵌套循环）
outer: for i in 0..10 {
    for j in 0..10 {
        if i * j > 50 {
            break outer     // 退出外层循环
        }
    }
}
```

### match 表达式

```
// 基本匹配
var result:string = match value {
    1 => "one"
    2 => "two"
    3 => "three"
    _ => "other"            // 默认分支（必须穷尽所有情况）
}

// 多值匹配
match value {
    1, 2, 3 => {
        // 匹配 1 或 2 或 3
    }
    4..10 => {
        // 匹配 4 到 9
    }
    _ => {
        // 其他
    }
}

// 条件守卫
match value {
    n if n > 0 => "positive"
    n if n < 0 => "negative"
    _ => "zero"
}

// 类型匹配
match obj {
    s:string => "String: ${s}"
    n:int => "Int: ${n}"
    arr:int[] => "Array of ${arr.length} elements"
    _ => "Unknown type"
}

// 枚举匹配
match status {
    Status.Ok => handleOk()
    Status.Error(msg) => handleError(msg)
    Status.Pending => handlePending()
}
```

---

## 函数与闭包

### 闭包定义

```
// 所有函数都是闭包，赋值给变量或类属性
// 无返回值
var sayHello = fn() {
    print("Hello!")
}

// 有返回值
var add = fn(a:int, b:int) int {
    return a + b
}

// 多返回值
var divmod = fn(a:int, b:int) (int, int) {
    return a / b, a % b
}

// 接收多返回值（必须解构）
var q, r = divmod(10, 3)

// 返回可空类型
var find = fn(id:int) User? {
    // ...
    return null
}
```

### 参数

```
// 默认参数值
var greet = fn(name:string, greeting:string = "Hello") string {
    return "${greeting}, ${name}!"
}

greet("Alice")                  // "Hello, Alice!"
greet("Bob", "Hi")              // "Hi, Bob!"

// 命名参数调用
greet(name: "Charlie", greeting: "Hey")

// 可变参数（必须是最后一个参数）
var sum = fn(numbers:int...) int {
    var total:int = 0
    for n in numbers {
        total += n
    }
    return total
}

sum(1, 2, 3)                    // 6
sum(1, 2, 3, 4, 5)              // 15

// 展开数组作为可变参数
var arr:int[] = [1, 2, 3]
sum(arr...)                     // 6
```

### 闭包类型与高阶函数

```
// 闭包类型声明
type IntBinaryOp = fn(int, int) int
type Predicate = fn(int) bool

// 闭包作为参数
var apply = fn(a:int, b:int, op:fn(int, int) int) int {
    return op(a, b)
}

var multiply = fn(a:int, b:int) int {
    return a * b
}

var result:int = apply(3, 4, multiply)   // 12

// 闭包作为返回值
var makeAdder = fn(n:int) fn(int) int {
    return fn(x:int) int {
        return x + n
    }
}

var add5 = makeAdder(5)
add5(10)                        // 15
```

### 闭包捕获

```
var makeCounter = fn() fn() int {
    var count:int = 0
    return fn() int {
        count += 1              // 捕获外部变量
        return count
    }
}

var counter = makeCounter()
counter()   // 1
counter()   // 2
counter()   // 3
```

### 递归

```
// 闭包可以通过变量名引用自身（延迟绑定）
var factorial = fn(n:int) int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

factorial(5)    // 120
```

---

## 结构体

```
// 结构体是值类型，分配在栈上
// 结构体可以实现接口

struct Point {
    pub x:f64
    pub y:f64
    
    // 构造函数（可选，名为 init）
    fn init(x:f64, y:f64) {
        this.x = x
        this.y = y
    }
    
    // 构造函数重载
    fn init() {
        this.x = 0.0
        this.y = 0.0
    }
    
    // 实例方法
    pub fn distanceTo(other:Point) f64 {
        var dx:f64 = this.x - other.x
        var dy:f64 = this.y - other.y
        return Math::sqrt(dx * dx + dy * dy)
    }
    
    // 静态方法（通过 :: 调用）
    pub static fn origin() Point {
        return Point(0.0, 0.0)
    }
    
    // 静态常量
    pub static const ZERO:Point = Point(0.0, 0.0)
}

// 创建实例
var p1:Point = Point(3.0, 4.0)          // 调用构造函数
var p2:Point = Point()                   // 无参构造
var p3:Point = default                   // 所有字段默认值，不调用构造函数
var p4:Point = Point { x: 1.0, y: 2.0 } // 字段初始化器

// 调用静态方法/常量
var origin:Point = Point::origin()
var zero:Point = Point::ZERO

// 调用实例方法
var dist:f64 = p1.distanceTo(p2)
```

### 结构体实现接口

```
interface Drawable {
    fn draw()
}

struct Rectangle implements Drawable {
    pub x:f64
    pub y:f64
    pub width:f64
    pub height:f64
    
    pub fn draw() {
        // 绘制矩形
    }
    
    pub fn area() f64 {
        return this.width * this.height
    }
}
```

---

## 类

```
// 类是引用类型，分配在堆上
class Animal {
    // 字段（默认 priv）
    priv name:string
    prot age:int
    
    // 静态常量（用类组织常量）
    pub static const MAX_AGE:int = 100
    pub static const MIN_AGE:int = 0
    
    // 静态字段
    pub static count:int = 0
    
    // 构造函数（默认 pub）
    fn init(name:string, age:int) {
        this.name = name
        this.age = age
        Animal::count += 1
    }
    
    // 实例方法（默认 priv）
    pub fn getName() string {
        return this.name
    }
    
    // 虚方法（可被子类重写）
    pub fn speak() string {
        return "..."
    }
    
    // 静态方法
    pub static fn getCount() int {
        return Animal::count
    }
}

// 继承
class Dog extends Animal {
    priv breed:string
    
    fn init(name:string, age:int, breed:string) {
        super.init(name, age)       // 调用父类构造函数
        this.breed = breed
    }
    
    // 重写父类方法（必须用 override 标记）
    pub override fn speak() string {
        return "Woof!"
    }
    
    pub fn getBreed() string {
        return this.breed
    }
}

// 创建实例
var dog:Dog = new Dog("Buddy", 3, "Labrador")
var name:string = dog.getName()
var sound:string = dog.speak()      // "Woof!"

// 静态成员访问
var count:int = Animal::getCount()
var maxAge:int = Animal::MAX_AGE
```

### 可见性修饰符

```
pub     // public：所有地方可访问
priv    // private：仅当前类/结构体可访问（默认）
prot    // protected：当前类和子类可访问

// 构造函数默认为 pub
// 普通方法和字段默认为 priv
```

### 闭包属性

```
// 类可以有闭包类型的属性
class EventEmitter {
    // 闭包属性
    pub onEvent:fn(string)? = null
    
    pub fn emit(event:string) {
        if this.onEvent != null {
            this.onEvent!(event)
        }
    }
}

var emitter = new EventEmitter()
emitter.onEvent = fn(e:string) {
    print("Event: ${e}")
}
emitter.emit("click")
```

---

## 接口

```
// 接口定义行为契约（纯抽象，只有方法签名）
// 接口对结构体和类都适用

interface Drawable {
    fn draw()
    fn getBounds() Rectangle
}

interface Clickable {
    fn onClick(x:int, y:int)
}

// 类实现接口
class Button implements Drawable, Clickable {
    priv x:int
    priv y:int
    priv width:int
    priv height:int
    
    fn init(x:int, y:int, w:int, h:int) {
        this.x = x
        this.y = y
        this.width = w
        this.height = h
    }
    
    pub fn draw() {
        // 绘制按钮
    }
    
    pub fn getBounds() Rectangle {
        return Rectangle { 
            x: this.x as f64, 
            y: this.y as f64,
            width: this.width as f64, 
            height: this.height as f64 
        }
    }
    
    pub fn onClick(x:int, y:int) {
        // 处理点击
    }
}

// 结构体实现接口
struct Point implements Drawable {
    pub x:f64
    pub y:f64
    
    pub fn draw() {
        // 绘制点
    }
    
    pub fn getBounds() Rectangle {
        return Rectangle { x: this.x, y: this.y, width: 1.0, height: 1.0 }
    }
}

// 接口作为类型
var render = fn(item:Drawable) {
    item.draw()
}

var btn:Button = new Button(0, 0, 100, 50)
render(btn)

var pt:Point = Point(10.0, 20.0)
render(pt)
```

---

## Trait

```
// Trait 类似 Rust，可以有默认实现
trait Printable {
    // 抽象方法（必须实现）
    fn format() string
    
    // 默认实现（可选重写）
    fn print() {
        print(this.format())
    }
    
    fn println() {
        print(this.format() + "\n")
    }
}

trait Comparable<T> {
    fn compareTo(other:T) int
    
    fn lessThan(other:T) bool {
        return this.compareTo(other) < 0
    }
    
    fn greaterThan(other:T) bool {
        return this.compareTo(other) > 0
    }
    
    fn equals(other:T) bool {
        return this.compareTo(other) == 0
    }
}

// 使用 Trait
class User {
    pub name:string
    pub age:int
    
    use Printable
    use Comparable<User>
    
    fn init(name:string, age:int) {
        this.name = name
        this.age = age
    }
    
    // 实现 Printable.format
    pub fn format() string {
        return "User(${this.name}, ${this.age})"
    }
    
    // 实现 Comparable.compareTo
    pub fn compareTo(other:User) int {
        return this.age - other.age
    }
    
    // print() 和 println() 使用默认实现
    // lessThan(), greaterThan(), equals() 使用默认实现
}

var u1:User = new User("Alice", 25)
var u2:User = new User("Bob", 30)
u1.println()                    // 输出: User(Alice, 25)
u1.lessThan(u2)                 // true
```

---

## 抽象类

```
// 抽象类不能直接实例化
abstract class Shape {
    prot color:string
    
    fn init(color:string) {
        this.color = color
    }
    
    // 抽象方法（子类必须实现）
    pub abstract fn area() f64
    pub abstract fn perimeter() f64
    
    // 具体方法
    pub fn getColor() string {
        return this.color
    }
    
    pub fn describe() string {
        return "A ${this.color} shape with area ${this.area()}"
    }
}

class Circle extends Shape {
    priv radius:f64
    
    fn init(color:string, radius:f64) {
        super.init(color)
        this.radius = radius
    }
    
    pub override fn area() f64 {
        return 3.14159 * this.radius * this.radius
    }
    
    pub override fn perimeter() f64 {
        return 2.0 * 3.14159 * this.radius
    }
}
```

---

## 枚举

### 基本枚举

```
enum Color {
    Red,
    Green,
    Blue
}

var c:Color = Color.Red

// 枚举比较
if c == Color.Red {
    // ...
}

// match 枚举
match c {
    Color.Red => print("红色")
    Color.Green => print("绿色")
    Color.Blue => print("蓝色")
}
```

### 带值枚举

```
// 指定整数值
enum HttpStatus {
    Ok = 200,
    NotFound = 404,
    InternalError = 500
    
    // 静态常量
    pub static const SUCCESS_MIN:int = 200
    pub static const SUCCESS_MAX:int = 299
}

var status:HttpStatus = HttpStatus.Ok
var code:int = status.value             // 200

// 从值创建枚举
var s:HttpStatus? = HttpStatus.fromValue(404)

// 检查范围
var isSuccess = fn(s:HttpStatus) bool {
    return s.value >= HttpStatus::SUCCESS_MIN 
        && s.value <= HttpStatus::SUCCESS_MAX
}
```

### 关联值枚举（类似 Rust）

```
enum Result<T> {
    Ok(value:T),
    Err(message:string, code:int)
}

var divide = fn(a:int, b:int) Result<int> {
    if b == 0 {
        return Result.Err("Division by zero", -1)
    }
    return Result.Ok(a / b)
}

var result = divide(10, 2)
match result {
    Result.Ok(v) => print("Result: ${v}")
    Result.Err(msg, code) => print("Error ${code}: ${msg}")
}

// 判断枚举变体
if result is Result.Ok {
    // ...
}
```

### 枚举方法

```
enum Direction {
    North,
    South,
    East,
    West
    
    // 实例方法
    fn opposite() Direction {
        return match this {
            Direction.North => Direction.South
            Direction.South => Direction.North
            Direction.East => Direction.West
            Direction.West => Direction.East
        }
    }
    
    fn toString() string {
        return match this {
            Direction.North => "North"
            Direction.South => "South"
            Direction.East => "East"
            Direction.West => "West"
        }
    }
    
    // 静态方法
    static fn all() Direction[] {
        return [Direction.North, Direction.South, Direction.East, Direction.West]
    }
}

var dir:Direction = Direction.North
var opp:Direction = dir.opposite()      // South
var all:Direction[] = Direction::all()
```

---

## 泛型

### 泛型函数（作为类静态方法）

```
class Collections {
    pub static fn swap<T>(a:T, b:T) (T, T) {
        return b, a
    }
    
    pub static fn max<T: Comparable<T>>(a:T, b:T) T {
        return if a.greaterThan(b) { a } else { b }
    }
}

var x, y = Collections::swap<int>(1, 2)
var s1, s2 = Collections::swap("hello", "world")   // 类型推导
```

### 泛型类型约束

```
// 约束 T 必须实现 Comparable
class Sorter {
    pub static fn sort<T: Comparable<T>>(items:T[]) T[] {
        // 排序实现
    }
}

// 多约束（用 + 连接）
class Processor {
    pub static fn process<T: Printable + Comparable<T>>(item:T) {
        item.println()
    }
}

// where 子句（复杂约束）
class Converter {
    pub static fn convert<T, U>(a:T, b:U) T
        where T: Comparable<T>, U: Printable {
        // ...
    }
}
```

### 泛型结构体和类

```
struct Pair<K, V> {
    pub first:K
    pub second:V
    
    fn init(first:K, second:V) {
        this.first = first
        this.second = second
    }
}

var p:Pair<string, int> = Pair("age", 25)

// 泛型类
class Stack<T> {
    priv items:T[] = []
    
    pub fn push(item:T) {
        this.items.append(item)
    }
    
    pub fn pop() T? {
        if this.items.isEmpty() {
            return null
        }
        return this.items.remove(this.items.length - 1)
    }
    
    pub fn peek() T? {
        if this.items.isEmpty() {
            return null
        }
        return this.items[this.items.length - 1]
    }
    
    pub fn isEmpty() bool {
        return this.items.length == 0
    }
}

var stack:Stack<int> = new Stack<int>()
stack.push(1)
stack.push(2)
var top:int? = stack.pop()      // 2
```

### 泛型接口和 Trait

```
interface Container<T> {
    fn add(item:T)
    fn remove(item:T) bool
    fn contains(item:T) bool
    fn size() int
}

trait Mapper<In, Out> {
    fn map(input:In) Out
}
```

---

## 错误处理

### 异常

```
// try-catch-finally
try {
    var result = riskyOperation()
} catch (e:FileNotFoundException) {
    // 处理特定异常
    print("File not found: ${e.message}")
} catch (e:IOException) {
    // 处理 IO 异常
    print("IO error: ${e.message}")
} catch (e:Exception) {
    // 处理所有其他异常
    print("Error: ${e.message}")
} finally {
    // 无论是否异常都会执行
    cleanup()
}

// 抛出异常
var divide = fn(a:int, b:int) int {
    if b == 0 {
        throw new ArithmeticException("Division by zero")
    }
    return a / b
}
```

### 自定义异常

```
class ValidationException extends Exception {
    pub field:string
    
    fn init(field:string, message:string) {
        super.init(message)
        this.field = field
    }
}

// 使用
throw new ValidationException("email", "Invalid email format")
```

### Result 类型（函数式风格）

```
// 使用 Result 枚举代替异常
var parseInt = fn(s:string) Result<int> {
    // ...解析逻辑
    if success {
        return Result.Ok(value)
    } else {
        return Result.Err("Invalid number format", -1)
    }
}

// 使用
var result = parseInt("123")
match result {
    Result.Ok(n) => print("Parsed: ${n}")
    Result.Err(msg, _) => print("Error: ${msg}")
}
```

---

## 并发

### 协程（go 关键字）

```
// 启动协程
go doSomething()

// 带参数
go processItem(item)

// 使用闭包
go fn() {
    // 并发执行的代码
    var result = heavyComputation()
    print("Done: ${result}")
}()
```

### Channel（OOP 风格）

```
// 创建 Channel
var ch = new Channel<int>()                  // 无缓冲
var bufferedCh = new Channel<int>(10)        // 缓冲大小为10

// 发送数据
ch.send(42)

// 接收数据
var value:int = ch.receive()

// 非阻塞操作
var value2:int? = ch.tryReceive()            // 无数据返回 null
var sent:bool = ch.trySend(100)              // 无法发送返回 false

// 关闭 Channel
ch.close()

// 检查是否关闭
if ch.isClosed() {
    // ...
}

// 遍历 Channel（直到关闭）
for value in ch {
    print(value)
}
```

### Channel 选择（OOP 风格，代替 select 语句）

```
var ch1 = new Channel<int>()
var ch2 = new Channel<string>()

// 使用 Channel::select 静态方法
var result = Channel::select([
    ch1.onReceive(fn(v:int) {
        print("Received int: ${v}")
    }),
    ch2.onReceive(fn(s:string) {
        print("Received string: ${s}")
    }),
    ch1.onSend(42, fn() {
        print("Sent 42")
    })
])

// 带超时
var result2 = Channel::select([
    ch1.onReceive(fn(v:int) { /* ... */ })
], timeout: 1000)    // 1000ms 超时

// 非阻塞选择
var result3 = Channel::trySelect([
    ch1.onReceive(fn(v:int) { /* ... */ }),
    ch2.onReceive(fn(s:string) { /* ... */ })
])   // 无就绪返回 null
```

### 同步原语

```
// 互斥锁
var mutex = new Mutex()
mutex.lock()
// 临界区
mutex.unlock()

// 使用 with 自动解锁
with mutex.lock() {
    // 临界区，退出时自动解锁
}

// 读写锁
var rwLock = new RWLock()
rwLock.readLock()       // 读锁
rwLock.readUnlock()
rwLock.writeLock()      // 写锁
rwLock.writeUnlock()

// 等待组
var wg = new WaitGroup()
wg.add(3)               // 添加3个任务
wg.done()               // 完成一个任务
wg.wait()               // 等待所有任务完成

// 原子操作
var counter = new Atomic<int>(0)
counter.add(1)
counter.sub(1)
var current:int = counter.load()
counter.store(100)
var old:int = counter.swap(200)
```

---

## 模块系统

### 包声明

```
// 文件开头声明包名
package myapp.utils

// 包名对应目录结构
// myapp/
//   utils/
//     StringHelper.ml
//     MathHelper.ml
```

### 导入

```
// 导入类
import myapp.utils.StringHelper
import myapp.utils.MathHelper

// 直接使用
StringHelper::trim(" hello ")

// 导入并重命名
import myapp.utils.StringHelper as StrUtil

StrUtil::trim(" hello ")

// 导入多个
import myapp.utils.{StringHelper, MathHelper, DateHelper}

// 标准库导入
import std.io.Console
import std.collections.{List, Set, HashMap}
```

### 可见性

```
// pub: 对外公开（其他包可访问）
// 默认: 包内可见（同包的其他文件可访问）
// priv: 仅当前文件/类可见

package mylib

pub class PublicClass {         // 其他包可访问
    // ...
}

class InternalClass {           // 仅本包可访问
    // ...
}
```

---

## 特性/注解（Attribute）

### 使用注解

```
// 使用 @ 符号
@Deprecated("Use newMethod instead")
fn oldMethod() {
    // ...
}

@Route(url: "/api/users", method: "GET")
fn getUsers() Response {
    // ...
}

// 多个注解
@Serializable
@JsonName("user_info")
class UserInfo {
    @JsonField("user_name")
    pub name:string
    
    @JsonIgnore
    pub password:string
}
```

### 定义注解

```
// 使用 @Attribute 元注解定义自定义注解
@Attribute(target: AttributeTarget.Method)
class Route {
    pub url:string
    pub method:string = "GET"
    
    fn init(url:string, method:string = "GET") {
        this.url = url
        this.method = method
    }
}

@Attribute(
    target: AttributeTarget.Class,
    allowMultiple: true              // 允许重复使用
)
class Tag {
    pub value:string
    
    fn init(value:string) {
        this.value = value
    }
}

// 使用
@Tag("important")
@Tag("reviewed")
class Document {
    // ...
}
```

### 内置注解

```
@Deprecated(message:string)      // 标记已废弃
@Override                        // 标记方法重写
@Suppress(warnings:string[])     // 抑制警告
@Inline                          // 提示内联优化
@NoInline                        // 禁止内联
@Test                            // 标记测试方法
```

---

## 反射

```
import std.reflect.Type
import std.reflect.Field
import std.reflect.Method

class User {
    pub name:string
    pub age:int
    
    fn init(name:string, age:int) {
        this.name = name
        this.age = age
    }
    
    pub fn greet() string {
        return "Hello, I'm ${this.name}"
    }
}

// 获取类型信息
var userType:Type = typeof(User)
var instanceType:Type = typeof(user)     // 从实例获取

// 类型信息
userType.name                    // "User"
userType.package                 // 包名
userType.isClass                 // true
userType.isStruct                // false

// 获取字段
var fields:Field[] = userType.getFields()
for field in fields {
    print("${field.name}: ${field.type.name}")
}

// 获取方法
var methods:Method[] = userType.getMethods()
for method in methods {
    print("${method.name}(${method.parameters})")
}

// 获取注解
var annotations:Attribute[] = userType.getAttributes()
for attr in annotations {
    if attr is Route {
        var route:Route = attr as! Route
        print("Route: ${route.url}")
    }
}

// 动态创建实例
var user:User = userType.createInstance("Alice", 25) as! User

// 动态调用方法
var method:Method? = userType.getMethod("greet")
if method != null {
    var result:unknown = method.invoke(user)
    print(result as! string)
}

// 动态访问字段
var nameField:Field? = userType.getField("name")
if nameField != null {
    var name:unknown = nameField.get(user)
    nameField.set(user, "Bob")
}
```

---

## 内存管理

### GC 垃圾回收

```
// 内存管理由 GC 自动处理
// 开发者无需手动分配/释放内存

// 值类型（分配在栈上，作用域结束自动释放）
var point:Point = Point(1.0, 2.0)       // 栈分配
var arr:int[10]                          // 栈分配

// 引用类型（分配在堆上，由 GC 管理）
var user:User = new User("Alice", 25)    // 堆分配
var list:int[] = [1, 2, 3]               // 堆分配
```

### GC 控制（高级用法）

```
import std.runtime.GC

GC::collect()                            // 手动触发 GC
GC::disable()                            // 临时禁用 GC
GC::enable()                             // 重新启用 GC

// 获取内存信息
var stats:MemoryStats = GC::stats()
print("Heap used: ${stats.heapUsed}")
print("Heap total: ${stats.heapTotal}")
```

### 资源管理（with 语句）

```
// 自动资源管理
// 实现 Disposable 接口的对象可以使用 with

interface Disposable {
    fn dispose()
}

class FileHandle implements Disposable {
    priv handle:int
    
    fn init(path:string) {
        this.handle = openFile(path)
    }
    
    pub fn read() string {
        // ...
    }
    
    pub fn dispose() {
        closeFile(this.handle)
    }
}

// 使用 with 自动调用 dispose
with var file = new FileHandle("data.txt") {
    var content:string = file.read()
    // 退出 with 块时自动调用 file.dispose()
}

// 多个资源
with var file1 = new FileHandle("a.txt"),
     var file2 = new FileHandle("b.txt") {
    // ...
}
```

---

## 运算符

### 算术运算符

```
+       // 加法
-       // 减法
*       // 乘法
/       // 除法
%       // 取模
**      // 幂运算
```

### 比较运算符

```
==      // 等于
!=      // 不等于
<       // 小于
>       // 大于
<=      // 小于等于
>=      // 大于等于
```

### 逻辑运算符

```
&&      // 逻辑与
||      // 逻辑或
!       // 逻辑非
```

### 位运算符

```
&       // 按位与
|       // 按位或
^       // 按位异或
~       // 按位取反
<<      // 左移
>>      // 右移
```

### 赋值运算符

```
=       // 赋值
+=      // 加法赋值
-=      // 减法赋值
*=      // 乘法赋值
/=      // 除法赋值
%=      // 取模赋值
&=      // 按位与赋值
|=      // 按位或赋值
^=      // 按位异或赋值
<<=     // 左移赋值
>>=     // 右移赋值
```

### 其他运算符

```
++      // 自增（仅后缀）
--      // 自减（仅后缀）
?:      // 三元运算符
??      // 空值合并
?.      // 安全调用
!.      // 非空断言调用
..      // 范围（不含结束）
..=     // 范围（含结束）
as      // 类型转换
as!     // 强制类型转换
is      // 类型检查
in      // 成员检查/迭代
```

### 运算符优先级（从高到低）

```
1.  () [] . ?. !.           // 分组、索引、成员访问
2.  ++ -- ! ~ + -           // 一元运算符
3.  **                      // 幂运算
4.  * / %                   // 乘除
5.  + -                     // 加减
6.  << >>                   // 位移
7.  < <= > >= is as         // 比较、类型
8.  == !=                   // 等于
9.  &                       // 按位与
10. ^                       // 按位异或
11. |                       // 按位或
12. &&                      // 逻辑与
13. ||                      // 逻辑或
14. ??                      // 空值合并
15. ?:                      // 三元
16. = += -= *= /= 等        // 赋值
```

---

## 运算符重载

```
// 结构体和类可以重载运算符
struct Vector2 {
    pub x:f64
    pub y:f64
    
    fn init(x:f64, y:f64) {
        this.x = x
        this.y = y
    }
    
    // 重载 + 运算符
    pub fn operator+(other:Vector2) Vector2 {
        return Vector2(this.x + other.x, this.y + other.y)
    }
    
    // 重载 - 运算符
    pub fn operator-(other:Vector2) Vector2 {
        return Vector2(this.x - other.x, this.y - other.y)
    }
    
    // 重载 * 运算符（标量乘法）
    pub fn operator*(scalar:f64) Vector2 {
        return Vector2(this.x * scalar, this.y * scalar)
    }
    
    // 重载 == 运算符
    pub fn operator==(other:Vector2) bool {
        return this.x == other.x && this.y == other.y
    }
    
    // 重载一元 - 运算符
    pub fn operator-() Vector2 {
        return Vector2(-this.x, -this.y)
    }
    
    // 重载索引运算符
    pub fn operator[](index:int) f64 {
        return match index {
            0 => this.x
            1 => this.y
            _ => throw new IndexOutOfBoundsException()
        }
    }
}

// 使用
var v1:Vector2 = Vector2(1.0, 2.0)
var v2:Vector2 = Vector2(3.0, 4.0)
var v3:Vector2 = v1 + v2            // (4.0, 6.0)
var v4:Vector2 = v1 * 2.0           // (2.0, 4.0)
var neg:Vector2 = -v1               // (-1.0, -2.0)
var equal:bool = v1 == v2           // false
var x:f64 = v1[0]                   // 1.0
```

---

## 顶级语句与入口点

```
// 程序入口必须是一个类的静态方法 main
// 没有全局函数，没有顶级语句

package myapp

import std.io.Console

class Program {
    pub static fn main(args:string[]) {
        Console::println("Hello, World!")
    }
}
```

---

## 标准库概览

```
std.io              // 输入输出（Console 类等）
std.fs              // 文件系统（File, Directory 类等）
std.net             // 网络（Socket, TcpClient 类等）
std.http            // HTTP（HttpClient, HttpServer 类等）
std.json            // JSON（Json 类）
std.xml             // XML（Xml 类）
std.regex           // 正则表达式（Regex 类）
std.time            // 日期时间（DateTime, Duration 类等）
std.math            // 数学函数（Math 类）
std.crypto          // 加密（Hash, Cipher 类等）
std.collections     // 集合（List, Set, HashMap 类等）
std.concurrent      // 并发（Channel, Mutex, WaitGroup 类等）
std.reflect         // 反射（Type, Field, Method 类等）
std.runtime         // 运行时（GC 类等）
std.testing         // 测试框架（Test 类等）
```

---

## 内置函数列表

以下是语言内置的全局函数/操作，不属于任何类：

| 名称 | 说明 | 示例 |
|------|------|------|
| `print` | 输出到控制台（不换行） | `print("hello")` |
| `println` | 输出到控制台（换行） | `println("hello")` |
| `make` | 创建切片或 map | `make(int[], 10)`, `make(map[string]int)` |
| `typeof` | 获取类型信息（反射） | `typeof(obj)`, `typeof(User)` |
| `sizeof` | 获取类型大小（字节） | `sizeof(int)`, `sizeof(Point)` |
| `panic` | 触发运行时错误，终止程序 | `panic("fatal error")` |

**注意**：除以上列表外，不会添加其他全局函数。所有其他功能通过标准库的类提供。

---

## 示例程序

### Hello World

```
package myapp

class Program {
    pub static fn main(args:string[]) {
        println("Hello, World!")
    }
}
```

### 猜数字游戏

```
package myapp

import std.io.Console
import std.math.Math

class Program {
    pub static fn main(args:string[]) {
        var secret:int = Math::randomInt(1, 100)
        var attempts:int = 0
        
        println("猜一个1到100之间的数字！")
        
        for {
            var input:string = Console::readLine("请输入你的猜测: ")
            var guess:int? = input.toInt()
            
            if guess == null {
                println("请输入有效数字！")
                continue
            }
            
            attempts++
            
            match {
                guess! < secret => println("太小了！")
                guess! > secret => println("太大了！")
                _ => {
                    println("恭喜！你用了 ${attempts} 次猜对了！")
                    break
                }
            }
        }
    }
}
```

### HTTP 服务器

```
package myapp

import std.http.{HttpServer, Request, Response}

class UserController {
    @Route(url: "/", method: "GET")
    pub fn index(req:Request) Response {
        return Response::html("<h1>Welcome to MyLang!</h1>")
    }
    
    @Route(url: "/api/users", method: "GET")
    pub fn getUsers(req:Request) Response {
        var users = [
            { "name": "Alice", "age": 25 },
            { "name": "Bob", "age": 30 }
        ]
        return Response::json(users)
    }
}

class Program {
    pub static fn main(args:string[]) {
        var server = new HttpServer()
        server.register(new UserController())
        server.listen(8080)
        println("Server running at http://localhost:8080")
    }
}
```

### 并发示例

```
package myapp

import std.http.HttpClient
import std.concurrent.{Channel, WaitGroup}

class Program {
    pub static fn main(args:string[]) {
        var urls:string[] = [
            "https://api.example.com/users",
            "https://api.example.com/posts",
            "https://api.example.com/comments"
        ]
        
        var ch = new Channel<string>(urls.length)
        
        // 并发获取所有 URL
        for url in urls {
            go fn() {
                var response = HttpClient::get(url)
                ch.send(response.body)
            }()
        }
        
        // 收集结果
        var results:string[] = []
        for _ in 0..urls.length {
            results.append(ch.receive())
        }
        
        println("Fetched ${results.length} URLs")
    }
}
```

### 使用 Channel::select

```
package myapp

import std.concurrent.Channel

class Program {
    pub static fn main(args:string[]) {
        var numbers = new Channel<int>(10)
        var done = new Channel<bool>()
        
        // 生产者
        go fn() {
            for i in 0..10 {
                numbers.send(i)
            }
            numbers.close()
        }()
        
        // 消费者
        go fn() {
            for {
                var result = Channel::select([
                    numbers.onReceive(fn(n:int) {
                        println("Received: ${n}")
                    })
                ], timeout: 1000)
                
                if result == null || numbers.isClosed() {
                    break
                }
            }
            done.send(true)
        }()
        
        // 等待完成
        done.receive()
        println("Done!")
    }
}
```
